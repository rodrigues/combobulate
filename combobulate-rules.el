;; START Auto-generated production rules for `yaml'
(defconst combobulate-rules-yaml 
 '(("alias" (:*unnamed* ("alias_name"))) 
 ("anchor" (:*unnamed* ("anchor_name"))) 
 ("block_mapping" (:*unnamed* ("block_mapping_pair"))) 
 ("block_mapping_pair" (:key ("flow_node" "block_node") :value ("flow_node" "block_node"))) 
 ("block_node" (:*unnamed* ("anchor" "block_sequence" "tag" "block_scalar" "block_mapping"))) 
 ("block_sequence" (:*unnamed* ("block_sequence_item"))) 
 ("block_sequence_item" (:*unnamed* ("flow_node" "block_node"))) 
 ("document" (:*unnamed* ("tag_directive" "reserved_directive" "flow_node" "block_node" "yaml_directive"))) 
 ("double_quote_scalar" (:*unnamed* ("escape_sequence"))) 
 ("flow_mapping" (:*unnamed* ("flow_pair" "flow_node"))) 
 ("flow_node" (:*unnamed* ("tag" "plain_scalar" "double_quote_scalar" "anchor" "single_quote_scalar" "alias" "flow_sequence" "flow_mapping"))) 
 ("flow_pair" (:key ("flow_node") :value ("flow_node"))) 
 ("flow_sequence" (:*unnamed* ("flow_pair" "flow_node"))) 
 ("plain_scalar" (:*unnamed* ("boolean_scalar" "null_scalar" "integer_scalar" "float_scalar" "string_scalar"))) 
 ("reserved_directive" (:*unnamed* ("directive_parameter" "directive_name"))) 
 ("single_quote_scalar" (:*unnamed* ("escape_sequence"))) 
 ("stream" (:*unnamed* ("document"))) 
 ("tag_directive" (:*unnamed* ("tag_handle" "tag_prefix"))) 
 ("yaml_directive" (:*unnamed* ("yaml_version"))) 
))

(defconst combobulate-rules-yaml-inverted 
 '(("alias_name" ("alias"))
   ("anchor_name" ("anchor"))
   ("block_mapping_pair" ("block_mapping"))
   ("flow_node" ("block_mapping_pair" "flow_pair" "block_sequence_item" "flow_sequence" "flow_mapping" "document"))
   ("block_node" ("block_mapping_pair" "block_sequence_item" "document"))
   ("anchor" ("flow_node" "block_node"))
   ("block_sequence" ("block_node"))
   ("tag" ("flow_node" "block_node"))
   ("block_scalar" ("block_node"))
   ("block_mapping" ("block_node"))
   ("block_sequence_item" ("block_sequence"))
   ("tag_directive" ("document"))
   ("reserved_directive" ("document"))
   ("yaml_directive" ("document"))
   ("escape_sequence" ("single_quote_scalar" "double_quote_scalar"))
   ("flow_pair" ("flow_mapping" "flow_sequence"))
   ("plain_scalar" ("flow_node"))
   ("double_quote_scalar" ("flow_node"))
   ("single_quote_scalar" ("flow_node"))
   ("alias" ("flow_node"))
   ("flow_sequence" ("flow_node"))
   ("flow_mapping" ("flow_node"))
   ("boolean_scalar" ("plain_scalar"))
   ("null_scalar" ("plain_scalar"))
   ("integer_scalar" ("plain_scalar"))
   ("float_scalar" ("plain_scalar"))
   ("string_scalar" ("plain_scalar"))
   ("directive_parameter" ("reserved_directive"))
   ("directive_name" ("reserved_directive"))
   ("document" ("stream"))
   ("tag_handle" ("tag_directive"))
   ("tag_prefix" ("tag_directive"))
   ("yaml_version" ("yaml_directive"))
  ) 
)
;; END production rules for yaml





;; START Auto-generated production rules for `tsx'
(defconst combobulate-rules-tsx 
 '(("_primary_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("declaration" (:*unnamed* ("function_declaration" "enum_declaration" "function_signature" "generator_function_declaration" "internal_module" "variable_declaration" "module" "class_declaration" "interface_declaration" "abstract_class_declaration" "import_alias" "lexical_declaration" "type_alias_declaration" "ambient_declaration"))) 
 ("expression" (:*unnamed* ("satisfies_expression" "jsx_self_closing_element" "primary_expression" "ternary_expression" "yield_expression" "internal_module" "await_expression" "assignment_expression" "glimmer_template" "binary_expression" "jsx_element" "as_expression" "jsx_fragment" "augmented_assignment_expression" "unary_expression" "update_expression" "new_expression"))) 
 ("pattern" (:*unnamed* ("non_null_expression" "member_expression" "rest_pattern" "object_pattern" "identifier" "subscript_expression" "array_pattern" "undefined"))) 
 ("primary_expression" (:*unnamed* ("member_expression" "false" "null" "regex" "identifier" "string" "parenthesized_expression" "subscript_expression" "super" "number" "function" "undefined" "import" "meta_property" "array" "true" "arrow_function" "non_null_expression" "generator_function" "object" "template_string" "this" "call_expression" "class"))) 
 ("statement" (:*unnamed* ("for_statement" "with_statement" "if_statement" "while_statement" "do_statement" "import_statement" "export_statement" "empty_statement" "break_statement" "for_in_statement" "continue_statement" "return_statement" "switch_statement" "try_statement" "expression_statement" "statement_block" "labeled_statement" "debugger_statement" "declaration" "throw_statement"))) 
 ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("ambient_declaration" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "property_identifier" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "statement_block" "union_type" "predefined_type" "index_type_query" "declaration" "readonly_type" "infer_type"))) 
 ("arguments" (:*unnamed* ("spread_element" "expression"))) 
 ("array" (:*unnamed* ("spread_element" "expression"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("array_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("as_expression" (:*unnamed* ("parenthesized_type" "expression" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("asserts" (:*unnamed* ("type_predicate" "identifier" "this"))) 
 ("assignment_expression" (:left ("non_null_expression" "member_expression" "object_pattern" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined") :right ("expression"))) 
 ("assignment_pattern" (:left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:left ("non_null_expression" "member_expression" "identifier" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:label ("statement_identifier"))) 
 ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :type_arguments ("type_arguments"))) 
 ("call_signature" (:parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("catch_clause" (:body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern") :type ("type_annotation"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_body" (:*unnamed* ("index_signature" "decorator" "method_definition" "method_signature" "public_field_definition" "class_static_block" "abstract_method_signature"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_heritage" (:*unnamed* ("extends_clause" "implements_clause"))) 
 ("class_static_block" (:body ("statement_block"))) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("conditional_type" (:alternative ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :consequence ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :left ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :right ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("constraint" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("construct_signature" (:parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters"))) 
 ("constructor_type" (:parameters ("formal_parameters") :type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :type_parameters ("type_parameters"))) 
 ("continue_statement" (:label ("statement_identifier"))) 
 ("decorator" (:*unnamed* ("identifier" "call_expression" "member_expression"))) 
 ("default_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("do_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("enum_assignment" (:name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("enum_body" (:*unnamed* ("enum_assignment") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name"))) 
 ("enum_declaration" (:body ("enum_body") :name ("identifier"))) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier"))) 
 ("export_statement" (:*unnamed* ("namespace_export" "identifier" "export_clause" "expression") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("extends_clause" (:type_arguments ("type_arguments") :value ("expression"))) 
 ("extends_type_clause" (:type ("type_identifier" "generic_type" "nested_type_identifier"))) 
 ("finally_clause" (:body ("statement_block"))) 
 ("flow_maybe_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("for_in_statement" (:body ("statement") :kind nil :left ("non_null_expression" "member_expression" "object_pattern" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined") :operator nil :right ("sequence_expression" "expression") :value ("expression"))) 
 ("for_statement" (:body ("statement") :condition ("empty_statement" "expression_statement") :increment ("sequence_expression" "expression") :initializer ("variable_declaration" "lexical_declaration" "empty_statement" "expression_statement"))) 
 ("formal_parameters" (:*unnamed* ("optional_parameter" "required_parameter"))) 
 ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("function_signature" (:name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("function_type" (:parameters ("formal_parameters") :return_type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "type_predicate" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :type_parameters ("type_parameters"))) 
 ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("generic_type" (:name ("type_identifier" "nested_type_identifier") :type_arguments ("type_arguments"))) 
 ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("implements_clause" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("import_alias" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_require_clause" (:*unnamed* ("identifier") :source ("string"))) 
 ("import_specifier" (:alias ("identifier") :name ("string" "identifier"))) 
 ("import_statement" (:*unnamed* ("import_clause" "import_require_clause") :source ("string"))) 
 ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :name ("identifier") :sign nil :type ("opting_type_annotation" "omitting_type_annotation" "type_annotation"))) 
 ("index_type_query" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("infer_type" (:*unnamed* ("type_identifier"))) 
 ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("internal_module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier"))) 
 ("intersection_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("jsx_attribute" (:*unnamed* ("string" "property_identifier" "jsx_namespace_name" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_closing_element" (:name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("jsx_element" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("spread_element" "sequence_expression" "expression"))) 
 ("jsx_fragment" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name") :type_arguments ("type_arguments"))) 
 ("jsx_self_closing_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name") :type_arguments ("type_arguments"))) 
 ("labeled_statement" (:body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("literal_type" (:*unnamed* ("null" "string" "number" "unary_expression" "undefined" "true" "false"))) 
 ("lookup_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("mapped_type_clause" (:alias ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :name ("type_identifier") :type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("member_expression" (:object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier"))) 
 ("method_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :body ("statement_block") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("method_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("string" "identifier"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("nested_identifier" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("nested_type_identifier" (:module ("identifier" "nested_identifier") :name ("type_identifier"))) 
 ("new_expression" (:arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments"))) 
 ("non_null_expression" (:*unnamed* ("expression"))) 
 ("object" (:*unnamed* ("spread_element" "method_definition" "pair" "shorthand_property_identifier"))) 
 ("object_assignment_pattern" (:left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "pair_pattern" "object_assignment_pattern" "shorthand_property_identifier_pattern"))) 
 ("object_type" (:*unnamed* ("index_signature" "call_signature" "property_signature" "construct_signature" "export_statement" "method_signature"))) 
 ("omitting_type_annotation" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("opting_type_annotation" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("optional_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("identifier") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression"))) 
 ("optional_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("pair" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("pair_pattern" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression") :type ("type_annotation"))) 
 ("parenthesized_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("property_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :type ("type_annotation"))) 
 ("public_field_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :type ("type_annotation") :value ("expression"))) 
 ("readonly_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("regex" (:flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("required_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("rest_pattern" "identifier") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression"))) 
 ("rest_pattern" (:*unnamed* ("non_null_expression" "member_expression" "identifier" "subscript_expression" "array_pattern" "undefined" "object_pattern"))) 
 ("rest_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("return_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("satisfies_expression" (:*unnamed* ("parenthesized_type" "expression" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression"))) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment"))) 
 ("subscript_expression" (:index ("string" "number" "expression" "predefined_type" "sequence_expression") :object ("expression") :optional_chain ("optional_chain"))) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:body ("statement") :value ("sequence_expression" "expression"))) 
 ("switch_default" (:body ("statement"))) 
 ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_literal_type" (:*unnamed* ("template_type"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression"))) 
 ("template_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query" "infer_type"))) 
 ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("tuple_type" (:*unnamed* ("parenthesized_type" "optional_type" "flow_maybe_type" "optional_parameter" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "rest_type" "constructor_type" "array_type" "union_type" "required_parameter" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_alias_declaration" (:name ("type_identifier") :type_parameters ("type_parameters") :value ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_annotation" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_arguments" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_parameter" (:constraint ("constraint") :name ("type_identifier") :value ("default_type"))) 
 ("type_parameters" (:*unnamed* ("type_parameter"))) 
 ("type_predicate" (:name ("identifier" "this") :type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_predicate_annotation" (:*unnamed* ("type_predicate"))) 
 ("type_query" (:*unnamed* ("identifier" "call_expression" "subscript_expression" "member_expression"))) 
 ("unary_expression" (:argument ("number" "expression") :operator nil)) 
 ("union_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("update_expression" (:argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:name ("identifier" "object_pattern" "array_pattern") :type ("type_annotation") :value ("expression"))) 
 ("while_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))

(defconst combobulate-rules-tsx-inverted 
 '(("parenthesized_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("flow_maybe_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("object_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "interface_declaration" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("nested_type_identifier" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "extends_type_clause" "generic_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("tuple_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("literal_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("existential_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("this_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("generic_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "extends_type_clause" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("type_identifier" ("flow_maybe_type" "nested_type_identifier" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "type_parameter" "omitting_type_annotation" "class" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "interface_declaration" "extends_type_clause" "abstract_class_declaration" "generic_type" "lookup_type" "conditional_type" "class_declaration" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature" "infer_type"))
   ("intersection_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("template_literal_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("lookup_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("conditional_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("type_query" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("array_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("union_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("predefined_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "subscript_expression" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("index_type_query" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("function_declaration" ("declaration"))
   ("enum_declaration" ("declaration"))
   ("function_signature" ("declaration"))
   ("generator_function_declaration" ("declaration"))
   ("internal_module" ("declaration" "expression"))
   ("variable_declaration" ("declaration" "for_statement"))
   ("module" ("declaration"))
   ("class_declaration" ("declaration"))
   ("interface_declaration" ("declaration"))
   ("abstract_class_declaration" ("declaration"))
   ("import_alias" ("declaration"))
   ("lexical_declaration" ("declaration" "for_statement"))
   ("type_alias_declaration" ("declaration"))
   ("ambient_declaration" ("declaration"))
   ("satisfies_expression" ("expression"))
   ("jsx_self_closing_element" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("primary_expression" ("new_expression" "expression"))
   ("ternary_expression" ("expression"))
   ("yield_expression" ("expression"))
   ("await_expression" ("expression"))
   ("assignment_expression" ("expression"))
   ("glimmer_template" ("expression"))
   ("binary_expression" ("expression"))
   ("jsx_element" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("as_expression" ("expression"))
   ("jsx_fragment" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("augmented_assignment_expression" ("expression"))
   ("unary_expression" ("literal_type" "expression"))
   ("update_expression" ("expression"))
   ("new_expression" ("expression"))
   ("non_null_expression" ("for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("member_expression" ("decorator" "for_in_statement" "type_query" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("rest_pattern" ("pattern" "object_pattern" "required_parameter"))
   ("object_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("identifier" ("enum_declaration" "import_clause" "nested_type_identifier" "jsx_self_closing_element" "primary_expression" "export_specifier" "namespace_export" "arrow_function" "function_declaration" "decorator" "variable_declarator" "type_predicate" "rest_pattern" "module" "nested_identifier" "import_specifier" "augmented_assignment_expression" "generator_function_declaration" "optional_parameter" "import_alias" "jsx_namespace_name" "function" "export_statement" "import_require_clause" "function_signature" "asserts" "catch_clause" "for_in_statement" "generator_function" "internal_module" "jsx_closing_element" "namespace_import" "type_query" "assignment_expression" "required_parameter" "jsx_opening_element" "pattern" "index_signature"))
   ("subscript_expression" ("for_in_statement" "type_query" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("array_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("undefined" ("for_in_statement" "rest_pattern" "assignment_expression" "literal_type" "primary_expression" "pattern"))
   ("false" ("literal_type" "primary_expression"))
   ("null" ("literal_type" "primary_expression"))
   ("regex" ("primary_expression"))
   ("string" ("enum_assignment" "enum_body" "jsx_attribute" "pair_pattern" "primary_expression" "export_specifier" "import_statement" "namespace_export" "method_definition" "module" "method_signature" "import_specifier" "abstract_method_signature" "public_field_definition" "literal_type" "subscript_expression" "export_statement" "pair" "import_require_clause" "internal_module" "property_signature"))
   ("parenthesized_expression" ("for_in_statement" "with_statement" "switch_statement" "assignment_expression" "while_statement" "primary_expression" "augmented_assignment_expression" "if_statement" "do_statement"))
   ("super" ("primary_expression"))
   ("number" ("method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "literal_type" "pair_pattern" "property_signature" "subscript_expression" "primary_expression" "unary_expression" "abstract_method_signature" "pair"))
   ("function" ("primary_expression"))
   ("import" ("primary_expression"))
   ("meta_property" ("primary_expression"))
   ("array" ("primary_expression"))
   ("true" ("literal_type" "primary_expression"))
   ("arrow_function" ("primary_expression"))
   ("generator_function" ("primary_expression"))
   ("object" ("primary_expression"))
   ("template_string" ("call_expression" "primary_expression"))
   ("this" ("asserts" "type_predicate" "optional_parameter" "primary_expression" "required_parameter"))
   ("call_expression" ("type_query" "decorator" "primary_expression"))
   ("class" ("primary_expression"))
   ("for_statement" ("statement"))
   ("with_statement" ("statement"))
   ("if_statement" ("statement"))
   ("while_statement" ("statement"))
   ("do_statement" ("statement"))
   ("import_statement" ("statement"))
   ("export_statement" ("statement" "object_type"))
   ("empty_statement" ("statement" "for_statement"))
   ("break_statement" ("statement"))
   ("for_in_statement" ("statement"))
   ("continue_statement" ("statement"))
   ("return_statement" ("statement"))
   ("switch_statement" ("statement"))
   ("try_statement" ("statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("statement_block" ("function_declaration" "generator_function_declaration" "generator_function" "catch_clause" "method_definition" "internal_module" "module" "try_statement" "ambient_declaration" "function" "finally_clause" "statement" "class_static_block" "arrow_function"))
   ("labeled_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "ambient_declaration" "export_statement"))
   ("throw_statement" ("statement"))
   ("class_heritage" ("class" "abstract_class_declaration" "class_declaration"))
   ("class_body" ("class" "abstract_class_declaration" "class_declaration"))
   ("decorator" ("class_declaration" "optional_parameter" "abstract_class_declaration" "class_body" "required_parameter" "class" "export_statement"))
   ("type_parameters" ("function_declaration" "call_signature" "function_signature" "function_type" "generator_function" "generator_function_declaration" "method_definition" "type_alias_declaration" "class_declaration" "interface_declaration" "abstract_class_declaration" "constructor_type" "method_signature" "construct_signature" "function" "class" "abstract_method_signature" "arrow_function"))
   ("accessibility_modifier" ("method_definition" "public_field_definition" "optional_parameter" "method_signature" "property_signature" "required_parameter" "abstract_method_signature"))
   ("property_identifier" ("member_expression" "method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "jsx_attribute" "ambient_declaration" "pair_pattern" "property_signature" "abstract_method_signature" "pair"))
   ("private_property_identifier" ("member_expression" "method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "pair_pattern" "property_signature" "abstract_method_signature" "pair"))
   ("computed_property_name" ("method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "pair_pattern" "property_signature" "abstract_method_signature" "pair"))
   ("formal_parameters" ("function_declaration" "call_signature" "function_signature" "function_type" "generator_function" "generator_function_declaration" "method_definition" "method_signature" "constructor_type" "construct_signature" "function" "abstract_method_signature" "arrow_function"))
   ("type_predicate_annotation" ("function_declaration" "call_signature" "function_signature" "generator_function" "generator_function_declaration" "method_definition" "method_signature" "function" "abstract_method_signature" "arrow_function"))
   ("asserts" ("function_declaration" "call_signature" "function_signature" "generator_function" "generator_function_declaration" "method_definition" "method_signature" "function" "abstract_method_signature" "arrow_function"))
   ("type_annotation" ("parenthesized_expression" "arrow_function" "function_declaration" "call_signature" "method_definition" "variable_declarator" "method_signature" "construct_signature" "abstract_method_signature" "generator_function_declaration" "public_field_definition" "optional_parameter" "function" "function_signature" "catch_clause" "generator_function" "property_signature" "required_parameter" "index_signature"))
   ("function_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "index_signature"))
   ("constructor_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "index_signature"))
   ("readonly_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "index_signature"))
   ("infer_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "template_type" "index_signature"))
   ("spread_element" ("arguments" "array" "jsx_expression" "object"))
   ("expression" ("member_expression" "switch_case" "arguments" "enum_assignment" "throw_statement" "jsx_expression" "satisfies_expression" "parenthesized_expression" "array" "arrow_function" "non_null_expression" "yield_expression" "variable_declarator" "extends_clause" "return_statement" "as_expression" "call_expression" "augmented_assignment_expression" "unary_expression" "update_expression" "computed_property_name" "spread_element" "for_statement" "object_assignment_pattern" "public_field_definition" "optional_parameter" "subscript_expression" "template_substitution" "ternary_expression" "assignment_pattern" "export_statement" "pair" "for_in_statement" "await_expression" "assignment_expression" "binary_expression" "expression_statement" "required_parameter" "sequence_expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern"))
   ("pattern" ("optional_parameter" "pair_pattern" "array_pattern" "required_parameter" "assignment_pattern"))
   ("type_predicate" ("function_type" "asserts" "type_predicate_annotation"))
   ("statement_identifier" ("continue_statement" "labeled_statement" "break_statement"))
   ("arguments" ("new_expression" "call_expression"))
   ("type_arguments" ("extends_clause" "jsx_self_closing_element" "call_expression" "jsx_opening_element" "new_expression" "generic_type"))
   ("index_signature" ("object_type" "class_body"))
   ("method_definition" ("object" "class_body"))
   ("method_signature" ("object_type" "class_body"))
   ("public_field_definition" ("class_body"))
   ("class_static_block" ("class_body"))
   ("abstract_method_signature" ("class_body"))
   ("extends_clause" ("class_heritage"))
   ("implements_clause" ("class_heritage"))
   ("statement" ("switch_case" "for_statement" "for_in_statement" "switch_default" "with_statement" "else_clause" "program" "labeled_statement" "statement_block" "if_statement" "while_statement" "do_statement"))
   ("enum_assignment" ("enum_body"))
   ("enum_body" ("enum_declaration"))
   ("export_specifier" ("export_clause"))
   ("namespace_export" ("export_statement"))
   ("export_clause" ("export_statement"))
   ("sequence_expression" ("switch_case" "for_statement" "for_in_statement" "return_statement" "throw_statement" "jsx_expression" "expression_statement" "subscript_expression" "parenthesized_expression" "template_substitution" "sequence_expression"))
   ("optional_parameter" ("formal_parameters" "tuple_type"))
   ("required_parameter" ("formal_parameters" "tuple_type"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("else_clause" ("if_statement"))
   ("nested_identifier" ("internal_module" "jsx_closing_element" "module" "nested_identifier" "import_alias" "nested_type_identifier" "jsx_self_closing_element" "jsx_opening_element"))
   ("namespace_import" ("import_clause"))
   ("named_imports" ("import_clause"))
   ("import_clause" ("import_statement"))
   ("import_require_clause" ("import_statement"))
   ("mapped_type_clause" ("index_signature"))
   ("opting_type_annotation" ("index_signature"))
   ("omitting_type_annotation" ("index_signature"))
   ("extends_type_clause" ("interface_declaration"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_expression" ("jsx_element" "jsx_self_closing_element" "jsx_attribute" "jsx_fragment" "jsx_opening_element"))
   ("jsx_text" ("jsx_fragment" "jsx_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("optional_chain" ("member_expression" "subscript_expression"))
   ("override_modifier" ("method_definition" "public_field_definition" "optional_parameter" "method_signature" "property_signature" "required_parameter"))
   ("import_specifier" ("named_imports"))
   ("pair" ("object"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("pair_pattern" ("object_pattern"))
   ("object_assignment_pattern" ("object_pattern"))
   ("call_signature" ("object_type"))
   ("property_signature" ("object_type"))
   ("construct_signature" ("object_type"))
   ("hash_bang_line" ("program"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("escape_sequence" ("template_string" "string"))
   ("string_fragment" ("string"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_body" ("switch_statement"))
   ("template_type" ("template_literal_type"))
   ("template_substitution" ("template_string"))
   ("finally_clause" ("try_statement"))
   ("catch_clause" ("try_statement"))
   ("optional_type" ("tuple_type"))
   ("rest_type" ("tuple_type"))
   ("constraint" ("type_parameter"))
   ("default_type" ("type_parameter"))
   ("type_parameter" ("type_parameters"))
  ) 
)
;; END production rules for tsx





;; START Auto-generated production rules for `css'
(defconst combobulate-rules-css 
 '(("adjacent_sibling_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("arguments" (:*unnamed* ("plain_value" "descendant_selector" "color_value" "integer_value" "class_selector" "nesting_selector" "child_selector" "parenthesized_value" "pseudo_class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "binary_expression" "sibling_selector" "call_expression" "float_value" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("at_rule" (:*unnamed* ("feature_query" "block" "at_keyword" "binary_query" "parenthesized_query" "keyword_query" "unary_query" "selector_query"))) 
 ("attribute_selector" (:*unnamed* ("plain_value" "descendant_selector" "color_value" "integer_value" "class_selector" "nesting_selector" "child_selector" "parenthesized_value" "attribute_name" "pseudo_class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "binary_expression" "sibling_selector" "call_expression" "float_value" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("binary_expression" (:*unnamed* ("plain_value" "string_value" "color_value" "integer_value" "binary_expression" "float_value" "call_expression" "parenthesized_value"))) 
 ("binary_query" (:*unnamed* ("feature_query" "binary_query" "parenthesized_query" "keyword_query" "unary_query" "selector_query"))) 
 ("block" (:*unnamed* ("charset_statement" "rule_set" "namespace_statement" "supports_statement" "media_statement" "declaration" "keyframes_statement" "import_statement" "at_rule"))) 
 ("call_expression" (:*unnamed* ("arguments" "function_name"))) 
 ("charset_statement" (:*unnamed* ("plain_value" "string_value" "color_value" "integer_value" "binary_expression" "float_value" "call_expression" "parenthesized_value"))) 
 ("child_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("class_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector" "class_name"))) 
 ("declaration" (:*unnamed* ("plain_value" "string_value" "color_value" "integer_value" "binary_expression" "float_value" "call_expression" "parenthesized_value" "property_name" "important"))) 
 ("descendant_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("feature_query" (:*unnamed* ("plain_value" "string_value" "color_value" "integer_value" "feature_name" "binary_expression" "float_value" "call_expression" "parenthesized_value"))) 
 ("float_value" (:*unnamed* ("unit"))) 
 ("id_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "id_name" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("import_statement" (:*unnamed* ("feature_query" "plain_value" "string_value" "color_value" "integer_value" "binary_expression" "binary_query" "call_expression" "float_value" "parenthesized_query" "parenthesized_value" "keyword_query" "unary_query" "selector_query"))) 
 ("integer_value" (:*unnamed* ("unit"))) 
 ("keyframe_block" (:*unnamed* ("from" "block" "integer_value" "to"))) 
 ("keyframe_block_list" (:*unnamed* ("keyframe_block"))) 
 ("keyframes_statement" (:*unnamed* ("at_keyword" "keyframes_name" "keyframe_block_list"))) 
 ("media_statement" (:*unnamed* ("feature_query" "binary_query" "parenthesized_query" "keyword_query" "block" "unary_query" "selector_query"))) 
 ("namespace_statement" (:*unnamed* ("call_expression" "string_value" "namespace_name"))) 
 ("parenthesized_query" (:*unnamed* ("feature_query" "binary_query" "parenthesized_query" "keyword_query" "unary_query" "selector_query"))) 
 ("parenthesized_value" (:*unnamed* ("plain_value" "string_value" "color_value" "integer_value" "binary_expression" "float_value" "call_expression" "parenthesized_value"))) 
 ("pseudo_class_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "arguments" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector" "class_name"))) 
 ("pseudo_element_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("rule_set" (:*unnamed* ("block" "selectors"))) 
 ("selector_query" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("selectors" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("sibling_selector" (:*unnamed* ("pseudo_class_selector" "descendant_selector" "class_selector" "string_value" "tag_name" "id_selector" "pseudo_element_selector" "nesting_selector" "child_selector" "sibling_selector" "universal_selector" "attribute_selector" "adjacent_sibling_selector"))) 
 ("stylesheet" (:*unnamed* ("charset_statement" "rule_set" "namespace_statement" "supports_statement" "media_statement" "declaration" "keyframes_statement" "import_statement" "at_rule"))) 
 ("supports_statement" (:*unnamed* ("feature_query" "binary_query" "parenthesized_query" "keyword_query" "block" "unary_query" "selector_query"))) 
 ("unary_query" (:*unnamed* ("feature_query" "binary_query" "parenthesized_query" "keyword_query" "unary_query" "selector_query"))) 
))

(defconst combobulate-rules-css-inverted 
 '(("pseudo_class_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("descendant_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("class_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("string_value" ("charset_statement" "feature_query" "arguments" "child_selector" "parenthesized_value" "import_statement" "pseudo_element_selector" "declaration" "adjacent_sibling_selector" "selector_query" "descendant_selector" "class_selector" "namespace_statement" "pseudo_class_selector" "id_selector" "binary_expression" "sibling_selector" "attribute_selector" "selectors"))
   ("tag_name" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("id_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("pseudo_element_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("nesting_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("child_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("sibling_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("universal_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("attribute_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("adjacent_sibling_selector" ("pseudo_class_selector" "descendant_selector" "class_selector" "arguments" "id_selector" "pseudo_element_selector" "child_selector" "sibling_selector" "attribute_selector" "adjacent_sibling_selector" "selectors" "selector_query"))
   ("plain_value" ("charset_statement" "feature_query" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("color_value" ("charset_statement" "feature_query" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("integer_value" ("charset_statement" "feature_query" "keyframe_block" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("parenthesized_value" ("charset_statement" "feature_query" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("binary_expression" ("charset_statement" "feature_query" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("call_expression" ("charset_statement" "feature_query" "namespace_statement" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("float_value" ("charset_statement" "feature_query" "arguments" "binary_expression" "parenthesized_value" "attribute_selector" "declaration" "import_statement"))
   ("feature_query" ("supports_statement" "media_statement" "binary_query" "parenthesized_query" "import_statement" "at_rule" "unary_query"))
   ("block" ("rule_set" "supports_statement" "keyframe_block" "media_statement" "at_rule"))
   ("at_keyword" ("keyframes_statement" "at_rule"))
   ("binary_query" ("supports_statement" "media_statement" "binary_query" "parenthesized_query" "import_statement" "at_rule" "unary_query"))
   ("parenthesized_query" ("supports_statement" "media_statement" "binary_query" "parenthesized_query" "import_statement" "at_rule" "unary_query"))
   ("keyword_query" ("supports_statement" "media_statement" "binary_query" "parenthesized_query" "import_statement" "at_rule" "unary_query"))
   ("unary_query" ("supports_statement" "media_statement" "binary_query" "parenthesized_query" "import_statement" "at_rule" "unary_query"))
   ("selector_query" ("supports_statement" "media_statement" "binary_query" "parenthesized_query" "import_statement" "at_rule" "unary_query"))
   ("attribute_name" ("attribute_selector"))
   ("charset_statement" ("stylesheet" "block"))
   ("rule_set" ("stylesheet" "block"))
   ("namespace_statement" ("stylesheet" "block"))
   ("supports_statement" ("stylesheet" "block"))
   ("media_statement" ("stylesheet" "block"))
   ("declaration" ("stylesheet" "block"))
   ("keyframes_statement" ("stylesheet" "block"))
   ("import_statement" ("stylesheet" "block"))
   ("at_rule" ("stylesheet" "block"))
   ("arguments" ("call_expression" "pseudo_class_selector"))
   ("function_name" ("call_expression"))
   ("class_name" ("pseudo_class_selector" "class_selector"))
   ("property_name" ("declaration"))
   ("important" ("declaration"))
   ("feature_name" ("feature_query"))
   ("unit" ("float_value" "integer_value"))
   ("id_name" ("id_selector"))
   ("from" ("keyframe_block"))
   ("to" ("keyframe_block"))
   ("keyframe_block" ("keyframe_block_list"))
   ("keyframes_name" ("keyframes_statement"))
   ("keyframe_block_list" ("keyframes_statement"))
   ("namespace_name" ("namespace_statement"))
   ("selectors" ("rule_set"))
  ) 
)
;; END production rules for css





;; START Auto-generated production rules for `typescript'
(defconst combobulate-rules-typescript 
 '(("_primary_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("declaration" (:*unnamed* ("function_declaration" "enum_declaration" "function_signature" "generator_function_declaration" "internal_module" "variable_declaration" "module" "class_declaration" "interface_declaration" "abstract_class_declaration" "import_alias" "lexical_declaration" "type_alias_declaration" "ambient_declaration"))) 
 ("expression" (:*unnamed* ("unary_expression" "internal_module" "await_expression" "assignment_expression" "glimmer_template" "binary_expression" "satisfies_expression" "as_expression" "type_assertion" "primary_expression" "augmented_assignment_expression" "ternary_expression" "update_expression" "new_expression" "yield_expression"))) 
 ("pattern" (:*unnamed* ("non_null_expression" "member_expression" "rest_pattern" "object_pattern" "identifier" "subscript_expression" "array_pattern" "undefined"))) 
 ("primary_expression" (:*unnamed* ("member_expression" "false" "null" "regex" "identifier" "string" "parenthesized_expression" "subscript_expression" "super" "number" "function" "undefined" "import" "meta_property" "array" "true" "arrow_function" "non_null_expression" "generator_function" "object" "template_string" "this" "call_expression" "class"))) 
 ("statement" (:*unnamed* ("for_statement" "with_statement" "if_statement" "while_statement" "do_statement" "import_statement" "export_statement" "empty_statement" "break_statement" "for_in_statement" "continue_statement" "return_statement" "switch_statement" "try_statement" "expression_statement" "statement_block" "labeled_statement" "debugger_statement" "declaration" "throw_statement"))) 
 ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("ambient_declaration" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "property_identifier" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "statement_block" "union_type" "predefined_type" "index_type_query" "declaration" "readonly_type" "infer_type"))) 
 ("arguments" (:*unnamed* ("spread_element" "expression"))) 
 ("array" (:*unnamed* ("spread_element" "expression"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("array_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("as_expression" (:*unnamed* ("parenthesized_type" "expression" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("asserts" (:*unnamed* ("type_predicate" "identifier" "this"))) 
 ("assignment_expression" (:left ("non_null_expression" "member_expression" "object_pattern" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined") :right ("expression"))) 
 ("assignment_pattern" (:left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:left ("non_null_expression" "member_expression" "identifier" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:label ("statement_identifier"))) 
 ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :type_arguments ("type_arguments"))) 
 ("call_signature" (:parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("catch_clause" (:body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern") :type ("type_annotation"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_body" (:*unnamed* ("index_signature" "decorator" "method_definition" "method_signature" "public_field_definition" "class_static_block" "abstract_method_signature"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("class_heritage" (:*unnamed* ("extends_clause" "implements_clause"))) 
 ("class_static_block" (:body ("statement_block"))) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("conditional_type" (:alternative ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :consequence ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :left ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :right ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("constraint" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("construct_signature" (:parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters"))) 
 ("constructor_type" (:parameters ("formal_parameters") :type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :type_parameters ("type_parameters"))) 
 ("continue_statement" (:label ("statement_identifier"))) 
 ("decorator" (:*unnamed* ("identifier" "call_expression" "member_expression"))) 
 ("default_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("do_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("enum_assignment" (:name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("enum_body" (:*unnamed* ("enum_assignment") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name"))) 
 ("enum_declaration" (:body ("enum_body") :name ("identifier"))) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier"))) 
 ("export_statement" (:*unnamed* ("namespace_export" "identifier" "export_clause" "expression") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("extends_clause" (:type_arguments ("type_arguments") :value ("expression"))) 
 ("extends_type_clause" (:type ("type_identifier" "generic_type" "nested_type_identifier"))) 
 ("finally_clause" (:body ("statement_block"))) 
 ("flow_maybe_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("for_in_statement" (:body ("statement") :kind nil :left ("non_null_expression" "member_expression" "object_pattern" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined") :operator nil :right ("sequence_expression" "expression") :value ("expression"))) 
 ("for_statement" (:body ("statement") :condition ("empty_statement" "expression_statement") :increment ("sequence_expression" "expression") :initializer ("variable_declaration" "lexical_declaration" "empty_statement" "expression_statement"))) 
 ("formal_parameters" (:*unnamed* ("optional_parameter" "required_parameter"))) 
 ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("function_signature" (:name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("function_type" (:parameters ("formal_parameters") :return_type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "type_predicate" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :type_parameters ("type_parameters"))) 
 ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("generic_type" (:name ("type_identifier" "nested_type_identifier") :type_arguments ("type_arguments"))) 
 ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("implements_clause" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("import_alias" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_require_clause" (:*unnamed* ("identifier") :source ("string"))) 
 ("import_specifier" (:alias ("identifier") :name ("string" "identifier"))) 
 ("import_statement" (:*unnamed* ("import_clause" "import_require_clause") :source ("string"))) 
 ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :name ("identifier") :sign nil :type ("opting_type_annotation" "omitting_type_annotation" "type_annotation"))) 
 ("index_type_query" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query"))) 
 ("infer_type" (:*unnamed* ("type_identifier"))) 
 ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters"))) 
 ("internal_module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier"))) 
 ("intersection_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("jsx_attribute" (:*unnamed* ("string" "property_identifier" "jsx_namespace_name" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_closing_element" (:name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("jsx_element" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("spread_element" "sequence_expression" "expression"))) 
 ("jsx_fragment" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name") :type_arguments ("type_arguments"))) 
 ("jsx_self_closing_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name") :type_arguments ("type_arguments"))) 
 ("labeled_statement" (:body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("literal_type" (:*unnamed* ("null" "string" "number" "unary_expression" "undefined" "true" "false"))) 
 ("lookup_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("mapped_type_clause" (:alias ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type") :name ("type_identifier") :type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("member_expression" (:object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier"))) 
 ("method_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :body ("statement_block") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("method_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters") :return_type ("type_predicate_annotation" "asserts" "type_annotation") :type_parameters ("type_parameters"))) 
 ("module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("string" "identifier"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("nested_identifier" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("nested_type_identifier" (:module ("identifier" "nested_identifier") :name ("type_identifier"))) 
 ("new_expression" (:arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments"))) 
 ("non_null_expression" (:*unnamed* ("expression"))) 
 ("object" (:*unnamed* ("spread_element" "method_definition" "pair" "shorthand_property_identifier"))) 
 ("object_assignment_pattern" (:left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "pair_pattern" "object_assignment_pattern" "shorthand_property_identifier_pattern"))) 
 ("object_type" (:*unnamed* ("index_signature" "call_signature" "property_signature" "construct_signature" "export_statement" "method_signature"))) 
 ("omitting_type_annotation" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("opting_type_annotation" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("optional_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("identifier") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression"))) 
 ("optional_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("pair" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("pair_pattern" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression") :type ("type_annotation"))) 
 ("parenthesized_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("property_signature" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :type ("type_annotation"))) 
 ("public_field_definition" (:*unnamed* ("override_modifier" "accessibility_modifier") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :type ("type_annotation") :value ("expression"))) 
 ("readonly_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("regex" (:flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("required_parameter" (:*unnamed* ("override_modifier" "accessibility_modifier") :decorator ("decorator") :name ("rest_pattern" "identifier") :pattern ("pattern" "this") :type ("type_annotation") :value ("expression"))) 
 ("rest_pattern" (:*unnamed* ("non_null_expression" "member_expression" "identifier" "subscript_expression" "array_pattern" "undefined" "object_pattern"))) 
 ("rest_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("return_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("satisfies_expression" (:*unnamed* ("parenthesized_type" "expression" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression"))) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment"))) 
 ("subscript_expression" (:index ("string" "number" "expression" "predefined_type" "sequence_expression") :object ("expression") :optional_chain ("optional_chain"))) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:body ("statement") :value ("sequence_expression" "expression"))) 
 ("switch_default" (:body ("statement"))) 
 ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_literal_type" (:*unnamed* ("template_type"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression"))) 
 ("template_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "type_query" "array_type" "union_type" "predefined_type" "index_type_query" "infer_type"))) 
 ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("tuple_type" (:*unnamed* ("parenthesized_type" "optional_type" "flow_maybe_type" "optional_parameter" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "rest_type" "constructor_type" "array_type" "union_type" "required_parameter" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_alias_declaration" (:name ("type_identifier") :type_parameters ("type_parameters") :value ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_annotation" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_arguments" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_assertion" (:*unnamed* ("type_arguments" "expression"))) 
 ("type_parameter" (:constraint ("constraint") :name ("type_identifier") :value ("default_type"))) 
 ("type_parameters" (:*unnamed* ("type_parameter"))) 
 ("type_predicate" (:name ("identifier" "this") :type ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("type_predicate_annotation" (:*unnamed* ("type_predicate"))) 
 ("type_query" (:*unnamed* ("identifier" "call_expression" "subscript_expression" "member_expression"))) 
 ("unary_expression" (:argument ("number" "expression") :operator nil)) 
 ("union_type" (:*unnamed* ("parenthesized_type" "flow_maybe_type" "object_type" "nested_type_identifier" "tuple_type" "literal_type" "existential_type" "this_type" "generic_type" "type_identifier" "intersection_type" "template_literal_type" "lookup_type" "conditional_type" "function_type" "type_query" "constructor_type" "array_type" "union_type" "predefined_type" "index_type_query" "readonly_type" "infer_type"))) 
 ("update_expression" (:argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:name ("identifier" "object_pattern" "array_pattern") :type ("type_annotation") :value ("expression"))) 
 ("while_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))

(defconst combobulate-rules-typescript-inverted 
 '(("parenthesized_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("flow_maybe_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("object_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "interface_declaration" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("nested_type_identifier" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "extends_type_clause" "generic_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("tuple_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("literal_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("existential_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("this_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("generic_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "extends_type_clause" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("type_identifier" ("flow_maybe_type" "nested_type_identifier" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "type_parameter" "omitting_type_annotation" "class" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "interface_declaration" "extends_type_clause" "abstract_class_declaration" "generic_type" "lookup_type" "conditional_type" "class_declaration" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature" "infer_type"))
   ("intersection_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("template_literal_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("lookup_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("conditional_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("type_query" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("array_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("union_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("predefined_type" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "subscript_expression" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("index_type_query" ("flow_maybe_type" "satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "array_type" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "mapped_type_clause" "readonly_type" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "_primary_type" "union_type" "type_annotation" "index_type_query" "template_type" "index_signature"))
   ("function_declaration" ("declaration"))
   ("enum_declaration" ("declaration"))
   ("function_signature" ("declaration"))
   ("generator_function_declaration" ("declaration"))
   ("internal_module" ("declaration" "expression"))
   ("variable_declaration" ("declaration" "for_statement"))
   ("module" ("declaration"))
   ("class_declaration" ("declaration"))
   ("interface_declaration" ("declaration"))
   ("abstract_class_declaration" ("declaration"))
   ("import_alias" ("declaration"))
   ("lexical_declaration" ("declaration" "for_statement"))
   ("type_alias_declaration" ("declaration"))
   ("ambient_declaration" ("declaration"))
   ("unary_expression" ("literal_type" "expression"))
   ("await_expression" ("expression"))
   ("assignment_expression" ("expression"))
   ("glimmer_template" ("expression"))
   ("binary_expression" ("expression"))
   ("satisfies_expression" ("expression"))
   ("as_expression" ("expression"))
   ("type_assertion" ("expression"))
   ("primary_expression" ("new_expression" "expression"))
   ("augmented_assignment_expression" ("expression"))
   ("ternary_expression" ("expression"))
   ("update_expression" ("expression"))
   ("new_expression" ("expression"))
   ("yield_expression" ("expression"))
   ("non_null_expression" ("for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("member_expression" ("decorator" "for_in_statement" "type_query" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("rest_pattern" ("pattern" "object_pattern" "required_parameter"))
   ("object_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("identifier" ("enum_declaration" "import_clause" "nested_type_identifier" "jsx_self_closing_element" "primary_expression" "export_specifier" "namespace_export" "arrow_function" "function_declaration" "decorator" "variable_declarator" "type_predicate" "rest_pattern" "module" "nested_identifier" "import_specifier" "augmented_assignment_expression" "generator_function_declaration" "optional_parameter" "import_alias" "jsx_namespace_name" "function" "export_statement" "import_require_clause" "function_signature" "asserts" "catch_clause" "for_in_statement" "generator_function" "internal_module" "jsx_closing_element" "namespace_import" "type_query" "assignment_expression" "required_parameter" "jsx_opening_element" "pattern" "index_signature"))
   ("subscript_expression" ("for_in_statement" "type_query" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("array_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("undefined" ("for_in_statement" "rest_pattern" "assignment_expression" "literal_type" "primary_expression" "pattern"))
   ("false" ("literal_type" "primary_expression"))
   ("null" ("literal_type" "primary_expression"))
   ("regex" ("primary_expression"))
   ("string" ("enum_assignment" "enum_body" "jsx_attribute" "pair_pattern" "primary_expression" "export_specifier" "import_statement" "namespace_export" "method_definition" "module" "method_signature" "import_specifier" "abstract_method_signature" "public_field_definition" "literal_type" "subscript_expression" "export_statement" "pair" "import_require_clause" "internal_module" "property_signature"))
   ("parenthesized_expression" ("for_in_statement" "with_statement" "switch_statement" "assignment_expression" "while_statement" "primary_expression" "augmented_assignment_expression" "if_statement" "do_statement"))
   ("super" ("primary_expression"))
   ("number" ("method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "literal_type" "pair_pattern" "property_signature" "subscript_expression" "primary_expression" "unary_expression" "abstract_method_signature" "pair"))
   ("function" ("primary_expression"))
   ("import" ("primary_expression"))
   ("meta_property" ("primary_expression"))
   ("array" ("primary_expression"))
   ("true" ("literal_type" "primary_expression"))
   ("arrow_function" ("primary_expression"))
   ("generator_function" ("primary_expression"))
   ("object" ("primary_expression"))
   ("template_string" ("call_expression" "primary_expression"))
   ("this" ("asserts" "type_predicate" "optional_parameter" "primary_expression" "required_parameter"))
   ("call_expression" ("type_query" "decorator" "primary_expression"))
   ("class" ("primary_expression"))
   ("for_statement" ("statement"))
   ("with_statement" ("statement"))
   ("if_statement" ("statement"))
   ("while_statement" ("statement"))
   ("do_statement" ("statement"))
   ("import_statement" ("statement"))
   ("export_statement" ("statement" "object_type"))
   ("empty_statement" ("statement" "for_statement"))
   ("break_statement" ("statement"))
   ("for_in_statement" ("statement"))
   ("continue_statement" ("statement"))
   ("return_statement" ("statement"))
   ("switch_statement" ("statement"))
   ("try_statement" ("statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("statement_block" ("function_declaration" "generator_function_declaration" "generator_function" "catch_clause" "method_definition" "internal_module" "module" "try_statement" "ambient_declaration" "function" "finally_clause" "statement" "class_static_block" "arrow_function"))
   ("labeled_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "ambient_declaration" "export_statement"))
   ("throw_statement" ("statement"))
   ("class_heritage" ("class" "abstract_class_declaration" "class_declaration"))
   ("class_body" ("class" "abstract_class_declaration" "class_declaration"))
   ("decorator" ("class_declaration" "optional_parameter" "abstract_class_declaration" "class_body" "required_parameter" "class" "export_statement"))
   ("type_parameters" ("function_declaration" "call_signature" "function_signature" "function_type" "generator_function" "generator_function_declaration" "method_definition" "type_alias_declaration" "class_declaration" "interface_declaration" "abstract_class_declaration" "constructor_type" "method_signature" "construct_signature" "function" "class" "abstract_method_signature" "arrow_function"))
   ("accessibility_modifier" ("method_definition" "public_field_definition" "optional_parameter" "method_signature" "property_signature" "required_parameter" "abstract_method_signature"))
   ("property_identifier" ("member_expression" "method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "jsx_attribute" "ambient_declaration" "pair_pattern" "property_signature" "abstract_method_signature" "pair"))
   ("private_property_identifier" ("member_expression" "method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "pair_pattern" "property_signature" "abstract_method_signature" "pair"))
   ("computed_property_name" ("method_definition" "enum_assignment" "public_field_definition" "method_signature" "enum_body" "pair_pattern" "property_signature" "abstract_method_signature" "pair"))
   ("formal_parameters" ("function_declaration" "call_signature" "function_signature" "function_type" "generator_function" "generator_function_declaration" "method_definition" "method_signature" "constructor_type" "construct_signature" "function" "abstract_method_signature" "arrow_function"))
   ("type_predicate_annotation" ("function_declaration" "call_signature" "function_signature" "generator_function" "generator_function_declaration" "method_definition" "method_signature" "function" "abstract_method_signature" "arrow_function"))
   ("asserts" ("function_declaration" "call_signature" "function_signature" "generator_function" "generator_function_declaration" "method_definition" "method_signature" "function" "abstract_method_signature" "arrow_function"))
   ("type_annotation" ("parenthesized_expression" "arrow_function" "function_declaration" "call_signature" "method_definition" "variable_declarator" "method_signature" "construct_signature" "abstract_method_signature" "generator_function_declaration" "public_field_definition" "optional_parameter" "function" "function_signature" "catch_clause" "generator_function" "property_signature" "required_parameter" "index_signature"))
   ("function_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "index_signature"))
   ("constructor_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "index_signature"))
   ("readonly_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "index_signature"))
   ("infer_type" ("satisfies_expression" "tuple_type" "implements_clause" "opting_type_annotation" "constraint" "intersection_type" "function_type" "rest_type" "type_predicate" "type_alias_declaration" "as_expression" "default_type" "ambient_declaration" "omitting_type_annotation" "type_arguments" "readonly_type" "mapped_type_clause" "parenthesized_type" "optional_type" "lookup_type" "conditional_type" "constructor_type" "union_type" "type_annotation" "template_type" "index_signature"))
   ("spread_element" ("arguments" "array" "jsx_expression" "object"))
   ("expression" ("member_expression" "switch_case" "arguments" "enum_assignment" "throw_statement" "jsx_expression" "satisfies_expression" "parenthesized_expression" "array" "arrow_function" "non_null_expression" "yield_expression" "variable_declarator" "extends_clause" "return_statement" "as_expression" "call_expression" "augmented_assignment_expression" "unary_expression" "update_expression" "computed_property_name" "spread_element" "for_statement" "object_assignment_pattern" "public_field_definition" "optional_parameter" "subscript_expression" "template_substitution" "ternary_expression" "assignment_pattern" "export_statement" "pair" "for_in_statement" "await_expression" "assignment_expression" "binary_expression" "expression_statement" "type_assertion" "required_parameter" "sequence_expression"))
   ("assignment_pattern" ("pair_pattern" "array_pattern"))
   ("pattern" ("optional_parameter" "pair_pattern" "array_pattern" "required_parameter" "assignment_pattern"))
   ("type_predicate" ("function_type" "asserts" "type_predicate_annotation"))
   ("statement_identifier" ("continue_statement" "labeled_statement" "break_statement"))
   ("arguments" ("new_expression" "call_expression"))
   ("type_arguments" ("extends_clause" "jsx_self_closing_element" "call_expression" "type_assertion" "jsx_opening_element" "new_expression" "generic_type"))
   ("index_signature" ("object_type" "class_body"))
   ("method_definition" ("object" "class_body"))
   ("method_signature" ("object_type" "class_body"))
   ("public_field_definition" ("class_body"))
   ("class_static_block" ("class_body"))
   ("abstract_method_signature" ("class_body"))
   ("extends_clause" ("class_heritage"))
   ("implements_clause" ("class_heritage"))
   ("statement" ("switch_case" "for_statement" "for_in_statement" "switch_default" "with_statement" "else_clause" "program" "labeled_statement" "statement_block" "if_statement" "while_statement" "do_statement"))
   ("enum_assignment" ("enum_body"))
   ("enum_body" ("enum_declaration"))
   ("export_specifier" ("export_clause"))
   ("namespace_export" ("export_statement"))
   ("export_clause" ("export_statement"))
   ("sequence_expression" ("switch_case" "for_statement" "for_in_statement" "return_statement" "throw_statement" "jsx_expression" "expression_statement" "subscript_expression" "parenthesized_expression" "template_substitution" "sequence_expression"))
   ("optional_parameter" ("formal_parameters" "tuple_type"))
   ("required_parameter" ("formal_parameters" "tuple_type"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("else_clause" ("if_statement"))
   ("nested_identifier" ("internal_module" "jsx_closing_element" "module" "nested_identifier" "import_alias" "nested_type_identifier" "jsx_self_closing_element" "jsx_opening_element"))
   ("namespace_import" ("import_clause"))
   ("named_imports" ("import_clause"))
   ("import_clause" ("import_statement"))
   ("import_require_clause" ("import_statement"))
   ("mapped_type_clause" ("index_signature"))
   ("opting_type_annotation" ("index_signature"))
   ("omitting_type_annotation" ("index_signature"))
   ("extends_type_clause" ("interface_declaration"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_fragment" ("jsx_attribute" "jsx_fragment" "jsx_element"))
   ("jsx_element" ("jsx_attribute" "jsx_fragment" "jsx_element"))
   ("jsx_expression" ("jsx_element" "jsx_self_closing_element" "jsx_attribute" "jsx_fragment" "jsx_opening_element"))
   ("jsx_self_closing_element" ("jsx_attribute" "jsx_fragment" "jsx_element"))
   ("jsx_text" ("jsx_fragment" "jsx_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("optional_chain" ("member_expression" "subscript_expression"))
   ("override_modifier" ("method_definition" "public_field_definition" "optional_parameter" "method_signature" "property_signature" "required_parameter"))
   ("import_specifier" ("named_imports"))
   ("pair" ("object"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("pair_pattern" ("object_pattern"))
   ("object_assignment_pattern" ("object_pattern"))
   ("call_signature" ("object_type"))
   ("property_signature" ("object_type"))
   ("construct_signature" ("object_type"))
   ("hash_bang_line" ("program"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("escape_sequence" ("template_string" "string"))
   ("string_fragment" ("string"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_body" ("switch_statement"))
   ("template_type" ("template_literal_type"))
   ("template_substitution" ("template_string"))
   ("finally_clause" ("try_statement"))
   ("catch_clause" ("try_statement"))
   ("optional_type" ("tuple_type"))
   ("rest_type" ("tuple_type"))
   ("constraint" ("type_parameter"))
   ("default_type" ("type_parameter"))
   ("type_parameter" ("type_parameters"))
  ) 
)
;; END production rules for typescript





;; START Auto-generated production rules for `javascript'
(defconst combobulate-rules-javascript 
 '(("declaration" (:*unnamed* ("function_declaration" "generator_function_declaration" "variable_declaration" "class_declaration" "lexical_declaration"))) 
 ("expression" (:*unnamed* ("unary_expression" "await_expression" "glimmer_template" "assignment_expression" "binary_expression" "jsx_element" "jsx_self_closing_element" "jsx_fragment" "primary_expression" "augmented_assignment_expression" "ternary_expression" "update_expression" "new_expression" "yield_expression"))) 
 ("pattern" (:*unnamed* ("member_expression" "identifier" "subscript_expression" "array_pattern" "rest_pattern" "undefined" "object_pattern"))) 
 ("primary_expression" (:*unnamed* ("member_expression" "false" "null" "regex" "identifier" "string" "parenthesized_expression" "subscript_expression" "super" "number" "function" "undefined" "import" "meta_property" "array" "true" "arrow_function" "generator_function" "object" "template_string" "this" "call_expression" "class"))) 
 ("statement" (:*unnamed* ("for_statement" "with_statement" "if_statement" "while_statement" "do_statement" "import_statement" "export_statement" "empty_statement" "break_statement" "for_in_statement" "continue_statement" "return_statement" "switch_statement" "try_statement" "expression_statement" "statement_block" "labeled_statement" "debugger_statement" "declaration" "throw_statement"))) 
 ("arguments" (:*unnamed* ("spread_element" "expression"))) 
 ("array" (:*unnamed* ("spread_element" "expression"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters"))) 
 ("assignment_expression" (:left ("member_expression" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined" "object_pattern") :right ("expression"))) 
 ("assignment_pattern" (:left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:left ("identifier" "member_expression" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:label ("statement_identifier"))) 
 ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :optional_chain ("optional_chain"))) 
 ("catch_clause" (:body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_body" (:member ("field_definition" "method_definition" "class_static_block") :template ("glimmer_template"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_heritage" (:*unnamed* ("expression"))) 
 ("class_static_block" (:body ("statement_block"))) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("continue_statement" (:label ("statement_identifier"))) 
 ("decorator" (:*unnamed* ("identifier" "call_expression" "member_expression"))) 
 ("do_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier"))) 
 ("export_statement" (:*unnamed* ("namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("field_definition" (:decorator ("decorator") :property ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("finally_clause" (:body ("statement_block"))) 
 ("for_in_statement" (:body ("statement") :kind nil :left ("member_expression" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined" "object_pattern") :operator nil :right ("sequence_expression" "expression") :value ("expression"))) 
 ("for_statement" (:body ("statement") :condition ("empty_statement" "expression_statement") :increment ("sequence_expression" "expression") :initializer ("variable_declaration" "lexical_declaration" "empty_statement" "expression_statement"))) 
 ("formal_parameters" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_specifier" (:alias ("identifier") :name ("string" "identifier"))) 
 ("import_statement" (:*unnamed* ("import_clause") :source ("string"))) 
 ("jsx_attribute" (:*unnamed* ("string" "property_identifier" "jsx_namespace_name" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_closing_element" (:name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("jsx_element" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("spread_element" "sequence_expression" "expression"))) 
 ("jsx_fragment" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("jsx_self_closing_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("labeled_statement" (:body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("member_expression" (:object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier"))) 
 ("method_definition" (:body ("statement_block") :decorator ("decorator") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("string" "identifier"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("nested_identifier" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("new_expression" (:arguments ("arguments") :constructor ("new_expression" "primary_expression"))) 
 ("object" (:*unnamed* ("spread_element" "method_definition" "pair" "shorthand_property_identifier"))) 
 ("object_assignment_pattern" (:left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "pair_pattern" "object_assignment_pattern" "shorthand_property_identifier_pattern"))) 
 ("pair" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("pair_pattern" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression"))) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("regex" (:flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("rest_pattern" (:*unnamed* ("member_expression" "identifier" "subscript_expression" "array_pattern" "undefined" "object_pattern"))) 
 ("return_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression"))) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment"))) 
 ("subscript_expression" (:index ("sequence_expression" "expression") :object ("expression") :optional_chain ("optional_chain"))) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:body ("statement") :value ("sequence_expression" "expression"))) 
 ("switch_default" (:body ("statement"))) 
 ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression"))) 
 ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("unary_expression" (:argument ("expression") :operator nil)) 
 ("update_expression" (:argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:name ("identifier" "object_pattern" "array_pattern") :value ("expression"))) 
 ("while_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))

(defconst combobulate-rules-javascript-inverted 
 '(("function_declaration" ("declaration"))
   ("generator_function_declaration" ("declaration"))
   ("variable_declaration" ("declaration" "for_statement"))
   ("class_declaration" ("declaration"))
   ("lexical_declaration" ("declaration" "for_statement"))
   ("unary_expression" ("expression"))
   ("await_expression" ("expression"))
   ("glimmer_template" ("class_body" "expression"))
   ("assignment_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("jsx_element" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("jsx_self_closing_element" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("jsx_fragment" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("primary_expression" ("new_expression" "expression"))
   ("augmented_assignment_expression" ("expression"))
   ("ternary_expression" ("expression"))
   ("update_expression" ("expression"))
   ("new_expression" ("new_expression" "expression"))
   ("yield_expression" ("expression"))
   ("member_expression" ("decorator" "for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("identifier" ("import_clause" "jsx_self_closing_element" "primary_expression" "export_specifier" "namespace_export" "arrow_function" "function_declaration" "decorator" "variable_declarator" "rest_pattern" "nested_identifier" "import_specifier" "augmented_assignment_expression" "class" "generator_function_declaration" "jsx_namespace_name" "function" "generator_function" "catch_clause" "for_in_statement" "namespace_import" "jsx_closing_element" "class_declaration" "assignment_expression" "jsx_opening_element" "pattern"))
   ("subscript_expression" ("for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("array_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("rest_pattern" ("pattern" "object_pattern"))
   ("undefined" ("for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "pattern"))
   ("object_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("false" ("primary_expression"))
   ("null" ("primary_expression"))
   ("regex" ("primary_expression"))
   ("string" ("method_definition" "namespace_export" "field_definition" "jsx_attribute" "import_specifier" "pair_pattern" "primary_expression" "export_specifier" "export_statement" "import_statement" "pair"))
   ("parenthesized_expression" ("for_in_statement" "with_statement" "switch_statement" "assignment_expression" "while_statement" "primary_expression" "augmented_assignment_expression" "if_statement" "do_statement"))
   ("super" ("primary_expression"))
   ("number" ("method_definition" "field_definition" "pair_pattern" "primary_expression" "pair"))
   ("function" ("primary_expression"))
   ("import" ("primary_expression"))
   ("meta_property" ("primary_expression"))
   ("array" ("primary_expression"))
   ("true" ("primary_expression"))
   ("arrow_function" ("primary_expression"))
   ("generator_function" ("primary_expression"))
   ("object" ("primary_expression"))
   ("template_string" ("call_expression" "primary_expression"))
   ("this" ("primary_expression"))
   ("call_expression" ("decorator" "primary_expression"))
   ("class" ("primary_expression"))
   ("for_statement" ("statement"))
   ("with_statement" ("statement"))
   ("if_statement" ("statement"))
   ("while_statement" ("statement"))
   ("do_statement" ("statement"))
   ("import_statement" ("statement"))
   ("export_statement" ("statement"))
   ("empty_statement" ("statement" "for_statement"))
   ("break_statement" ("statement"))
   ("for_in_statement" ("statement"))
   ("continue_statement" ("statement"))
   ("return_statement" ("statement"))
   ("switch_statement" ("statement"))
   ("try_statement" ("statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("statement_block" ("function_declaration" "generator_function_declaration" "generator_function" "catch_clause" "method_definition" "try_statement" "function" "finally_clause" "statement" "class_static_block" "arrow_function"))
   ("labeled_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement"))
   ("throw_statement" ("statement"))
   ("spread_element" ("arguments" "array" "jsx_expression" "object"))
   ("expression" ("member_expression" "switch_case" "arguments" "throw_statement" "jsx_expression" "parenthesized_expression" "array" "class_heritage" "arrow_function" "yield_expression" "variable_declarator" "return_statement" "call_expression" "augmented_assignment_expression" "unary_expression" "update_expression" "computed_property_name" "spread_element" "for_statement" "object_assignment_pattern" "field_definition" "subscript_expression" "template_substitution" "ternary_expression" "assignment_pattern" "export_statement" "pair" "for_in_statement" "await_expression" "assignment_expression" "binary_expression" "expression_statement" "sequence_expression"))
   ("assignment_pattern" ("pair_pattern" "formal_parameters" "array_pattern"))
   ("pattern" ("assignment_pattern" "pair_pattern" "formal_parameters" "array_pattern"))
   ("formal_parameters" ("function_declaration" "generator_function_declaration" "generator_function" "method_definition" "function" "arrow_function"))
   ("statement_identifier" ("continue_statement" "labeled_statement" "break_statement"))
   ("arguments" ("new_expression" "call_expression"))
   ("optional_chain" ("member_expression" "call_expression" "subscript_expression"))
   ("class_heritage" ("class" "class_declaration"))
   ("class_body" ("class" "class_declaration"))
   ("decorator" ("method_definition" "field_definition" "class_declaration" "class" "export_statement"))
   ("field_definition" ("class_body"))
   ("method_definition" ("object" "class_body"))
   ("class_static_block" ("class_body"))
   ("statement" ("switch_case" "for_statement" "for_in_statement" "switch_default" "with_statement" "else_clause" "program" "labeled_statement" "statement_block" "if_statement" "while_statement" "do_statement"))
   ("export_specifier" ("export_clause"))
   ("namespace_export" ("export_statement"))
   ("export_clause" ("export_statement"))
   ("sequence_expression" ("switch_case" "for_statement" "for_in_statement" "return_statement" "throw_statement" "jsx_expression" "expression_statement" "subscript_expression" "parenthesized_expression" "template_substitution" "sequence_expression"))
   ("property_identifier" ("member_expression" "method_definition" "field_definition" "jsx_attribute" "pair_pattern" "pair"))
   ("private_property_identifier" ("member_expression" "method_definition" "field_definition" "pair_pattern" "pair"))
   ("computed_property_name" ("field_definition" "method_definition" "pair_pattern" "pair"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("else_clause" ("if_statement"))
   ("namespace_import" ("import_clause"))
   ("named_imports" ("import_clause"))
   ("import_clause" ("import_statement"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_expression" ("jsx_element" "jsx_self_closing_element" "jsx_attribute" "jsx_fragment" "jsx_opening_element"))
   ("nested_identifier" ("jsx_closing_element" "jsx_opening_element" "nested_identifier" "jsx_self_closing_element"))
   ("jsx_text" ("jsx_fragment" "jsx_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("import_specifier" ("named_imports"))
   ("pair" ("object"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("pair_pattern" ("object_pattern"))
   ("object_assignment_pattern" ("object_pattern"))
   ("hash_bang_line" ("program"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("escape_sequence" ("template_string" "string"))
   ("string_fragment" ("string"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_body" ("switch_statement"))
   ("template_substitution" ("template_string"))
   ("finally_clause" ("try_statement"))
   ("catch_clause" ("try_statement"))
  ) 
)
;; END production rules for javascript





;; START Auto-generated production rules for `jsx'
(defconst combobulate-rules-jsx 
 '(("declaration" (:*unnamed* ("function_declaration" "generator_function_declaration" "variable_declaration" "class_declaration" "lexical_declaration"))) 
 ("expression" (:*unnamed* ("unary_expression" "await_expression" "glimmer_template" "assignment_expression" "binary_expression" "jsx_element" "jsx_self_closing_element" "jsx_fragment" "primary_expression" "augmented_assignment_expression" "ternary_expression" "update_expression" "new_expression" "yield_expression"))) 
 ("pattern" (:*unnamed* ("member_expression" "identifier" "subscript_expression" "array_pattern" "rest_pattern" "undefined" "object_pattern"))) 
 ("primary_expression" (:*unnamed* ("member_expression" "false" "null" "regex" "identifier" "string" "parenthesized_expression" "subscript_expression" "super" "number" "function" "undefined" "import" "meta_property" "array" "true" "arrow_function" "generator_function" "object" "template_string" "this" "call_expression" "class"))) 
 ("statement" (:*unnamed* ("for_statement" "with_statement" "if_statement" "while_statement" "do_statement" "import_statement" "export_statement" "empty_statement" "break_statement" "for_in_statement" "continue_statement" "return_statement" "switch_statement" "try_statement" "expression_statement" "statement_block" "labeled_statement" "debugger_statement" "declaration" "throw_statement"))) 
 ("arguments" (:*unnamed* ("spread_element" "expression"))) 
 ("array" (:*unnamed* ("spread_element" "expression"))) 
 ("array_pattern" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters"))) 
 ("assignment_expression" (:left ("member_expression" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined" "object_pattern") :right ("expression"))) 
 ("assignment_pattern" (:left ("pattern") :right ("expression"))) 
 ("augmented_assignment_expression" (:left ("identifier" "member_expression" "subscript_expression" "parenthesized_expression") :operator nil :right ("expression"))) 
 ("await_expression" (:*unnamed* ("expression"))) 
 ("binary_expression" (:left ("expression") :operator nil :right ("expression"))) 
 ("break_statement" (:label ("statement_identifier"))) 
 ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :optional_chain ("optional_chain"))) 
 ("catch_clause" (:body ("statement_block") :parameter ("identifier" "object_pattern" "array_pattern"))) 
 ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_body" (:member ("field_definition" "method_definition" "class_static_block") :template ("glimmer_template"))) 
 ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier"))) 
 ("class_heritage" (:*unnamed* ("expression"))) 
 ("class_static_block" (:body ("statement_block"))) 
 ("computed_property_name" (:*unnamed* ("expression"))) 
 ("continue_statement" (:label ("statement_identifier"))) 
 ("decorator" (:*unnamed* ("identifier" "call_expression" "member_expression"))) 
 ("do_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("else_clause" (:*unnamed* ("statement"))) 
 ("export_clause" (:*unnamed* ("export_specifier"))) 
 ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier"))) 
 ("export_statement" (:*unnamed* ("namespace_export" "export_clause") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression"))) 
 ("expression_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("field_definition" (:decorator ("decorator") :property ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("finally_clause" (:body ("statement_block"))) 
 ("for_in_statement" (:body ("statement") :kind nil :left ("member_expression" "identifier" "subscript_expression" "parenthesized_expression" "array_pattern" "undefined" "object_pattern") :operator nil :right ("sequence_expression" "expression") :value ("expression"))) 
 ("for_statement" (:body ("statement") :condition ("empty_statement" "expression_statement") :increment ("sequence_expression" "expression") :initializer ("variable_declaration" "lexical_declaration" "empty_statement" "expression_statement"))) 
 ("formal_parameters" (:*unnamed* ("assignment_pattern" "pattern"))) 
 ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters"))) 
 ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag"))) 
 ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement"))) 
 ("import_clause" (:*unnamed* ("identifier" "namespace_import" "named_imports"))) 
 ("import_specifier" (:alias ("identifier") :name ("string" "identifier"))) 
 ("import_statement" (:*unnamed* ("import_clause") :source ("string"))) 
 ("jsx_attribute" (:*unnamed* ("string" "property_identifier" "jsx_namespace_name" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_closing_element" (:name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("jsx_element" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element"))) 
 ("jsx_expression" (:*unnamed* ("spread_element" "sequence_expression" "expression"))) 
 ("jsx_fragment" (:*unnamed* ("jsx_text" "jsx_fragment" "jsx_element" "jsx_expression" "jsx_self_closing_element"))) 
 ("jsx_namespace_name" (:*unnamed* ("identifier"))) 
 ("jsx_opening_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("jsx_self_closing_element" (:attribute ("jsx_attribute" "jsx_expression") :name ("identifier" "nested_identifier" "jsx_namespace_name"))) 
 ("labeled_statement" (:body ("statement") :label ("statement_identifier"))) 
 ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil)) 
 ("member_expression" (:object ("expression") :optional_chain ("optional_chain") :property ("property_identifier" "private_property_identifier"))) 
 ("method_definition" (:body ("statement_block") :decorator ("decorator") :name ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :parameters ("formal_parameters"))) 
 ("named_imports" (:*unnamed* ("import_specifier"))) 
 ("namespace_export" (:*unnamed* ("string" "identifier"))) 
 ("namespace_import" (:*unnamed* ("identifier"))) 
 ("nested_identifier" (:*unnamed* ("identifier" "nested_identifier"))) 
 ("new_expression" (:arguments ("arguments") :constructor ("new_expression" "primary_expression"))) 
 ("object" (:*unnamed* ("spread_element" "method_definition" "pair" "shorthand_property_identifier"))) 
 ("object_assignment_pattern" (:left ("object_pattern" "shorthand_property_identifier_pattern" "array_pattern") :right ("expression"))) 
 ("object_pattern" (:*unnamed* ("rest_pattern" "pair_pattern" "object_assignment_pattern" "shorthand_property_identifier_pattern"))) 
 ("pair" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("expression"))) 
 ("pair_pattern" (:key ("string" "property_identifier" "number" "private_property_identifier" "computed_property_name") :value ("assignment_pattern" "pattern"))) 
 ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression"))) 
 ("program" (:*unnamed* ("statement" "hash_bang_line"))) 
 ("regex" (:flags ("regex_flags") :pattern ("regex_pattern"))) 
 ("rest_pattern" (:*unnamed* ("member_expression" "identifier" "subscript_expression" "array_pattern" "undefined" "object_pattern"))) 
 ("return_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression"))) 
 ("spread_element" (:*unnamed* ("expression"))) 
 ("statement_block" (:*unnamed* ("statement"))) 
 ("string" (:*unnamed* ("escape_sequence" "string_fragment"))) 
 ("subscript_expression" (:index ("sequence_expression" "expression") :object ("expression") :optional_chain ("optional_chain"))) 
 ("switch_body" (:*unnamed* ("switch_case" "switch_default"))) 
 ("switch_case" (:body ("statement") :value ("sequence_expression" "expression"))) 
 ("switch_default" (:body ("statement"))) 
 ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression"))) 
 ("template_string" (:*unnamed* ("escape_sequence" "template_substitution"))) 
 ("template_substitution" (:*unnamed* ("sequence_expression" "expression"))) 
 ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression"))) 
 ("throw_statement" (:*unnamed* ("sequence_expression" "expression"))) 
 ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause"))) 
 ("unary_expression" (:argument ("expression") :operator nil)) 
 ("update_expression" (:argument ("expression") :operator nil)) 
 ("variable_declaration" (:*unnamed* ("variable_declarator"))) 
 ("variable_declarator" (:name ("identifier" "object_pattern" "array_pattern") :value ("expression"))) 
 ("while_statement" (:body ("statement") :condition ("parenthesized_expression"))) 
 ("with_statement" (:body ("statement") :object ("parenthesized_expression"))) 
 ("yield_expression" (:*unnamed* ("expression"))) 
))

(defconst combobulate-rules-jsx-inverted 
 '(("function_declaration" ("declaration"))
   ("generator_function_declaration" ("declaration"))
   ("variable_declaration" ("declaration" "for_statement"))
   ("class_declaration" ("declaration"))
   ("lexical_declaration" ("declaration" "for_statement"))
   ("unary_expression" ("expression"))
   ("await_expression" ("expression"))
   ("glimmer_template" ("class_body" "expression"))
   ("assignment_expression" ("expression"))
   ("binary_expression" ("expression"))
   ("jsx_element" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("jsx_self_closing_element" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("jsx_fragment" ("jsx_attribute" "jsx_fragment" "jsx_element" "expression"))
   ("primary_expression" ("new_expression" "expression"))
   ("augmented_assignment_expression" ("expression"))
   ("ternary_expression" ("expression"))
   ("update_expression" ("expression"))
   ("new_expression" ("new_expression" "expression"))
   ("yield_expression" ("expression"))
   ("member_expression" ("decorator" "for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("identifier" ("import_clause" "jsx_self_closing_element" "primary_expression" "export_specifier" "namespace_export" "arrow_function" "function_declaration" "decorator" "variable_declarator" "rest_pattern" "nested_identifier" "import_specifier" "augmented_assignment_expression" "class" "generator_function_declaration" "jsx_namespace_name" "function" "generator_function" "catch_clause" "for_in_statement" "namespace_import" "jsx_closing_element" "class_declaration" "assignment_expression" "jsx_opening_element" "pattern"))
   ("subscript_expression" ("for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "augmented_assignment_expression" "pattern"))
   ("array_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("rest_pattern" ("pattern" "object_pattern"))
   ("undefined" ("for_in_statement" "rest_pattern" "assignment_expression" "primary_expression" "pattern"))
   ("object_pattern" ("variable_declarator" "for_in_statement" "object_assignment_pattern" "catch_clause" "rest_pattern" "assignment_expression" "pattern"))
   ("false" ("primary_expression"))
   ("null" ("primary_expression"))
   ("regex" ("primary_expression"))
   ("string" ("method_definition" "namespace_export" "field_definition" "jsx_attribute" "import_specifier" "pair_pattern" "primary_expression" "export_specifier" "export_statement" "import_statement" "pair"))
   ("parenthesized_expression" ("for_in_statement" "with_statement" "switch_statement" "assignment_expression" "while_statement" "primary_expression" "augmented_assignment_expression" "if_statement" "do_statement"))
   ("super" ("primary_expression"))
   ("number" ("method_definition" "field_definition" "pair_pattern" "primary_expression" "pair"))
   ("function" ("primary_expression"))
   ("import" ("primary_expression"))
   ("meta_property" ("primary_expression"))
   ("array" ("primary_expression"))
   ("true" ("primary_expression"))
   ("arrow_function" ("primary_expression"))
   ("generator_function" ("primary_expression"))
   ("object" ("primary_expression"))
   ("template_string" ("call_expression" "primary_expression"))
   ("this" ("primary_expression"))
   ("call_expression" ("decorator" "primary_expression"))
   ("class" ("primary_expression"))
   ("for_statement" ("statement"))
   ("with_statement" ("statement"))
   ("if_statement" ("statement"))
   ("while_statement" ("statement"))
   ("do_statement" ("statement"))
   ("import_statement" ("statement"))
   ("export_statement" ("statement"))
   ("empty_statement" ("statement" "for_statement"))
   ("break_statement" ("statement"))
   ("for_in_statement" ("statement"))
   ("continue_statement" ("statement"))
   ("return_statement" ("statement"))
   ("switch_statement" ("statement"))
   ("try_statement" ("statement"))
   ("expression_statement" ("statement" "for_statement"))
   ("statement_block" ("function_declaration" "generator_function_declaration" "generator_function" "catch_clause" "method_definition" "try_statement" "function" "finally_clause" "statement" "class_static_block" "arrow_function"))
   ("labeled_statement" ("statement"))
   ("debugger_statement" ("statement"))
   ("declaration" ("statement" "export_statement"))
   ("throw_statement" ("statement"))
   ("spread_element" ("arguments" "array" "jsx_expression" "object"))
   ("expression" ("member_expression" "switch_case" "arguments" "throw_statement" "jsx_expression" "parenthesized_expression" "array" "class_heritage" "arrow_function" "yield_expression" "variable_declarator" "return_statement" "call_expression" "augmented_assignment_expression" "unary_expression" "update_expression" "computed_property_name" "spread_element" "for_statement" "object_assignment_pattern" "field_definition" "subscript_expression" "template_substitution" "ternary_expression" "assignment_pattern" "export_statement" "pair" "for_in_statement" "await_expression" "assignment_expression" "binary_expression" "expression_statement" "sequence_expression"))
   ("assignment_pattern" ("pair_pattern" "formal_parameters" "array_pattern"))
   ("pattern" ("assignment_pattern" "pair_pattern" "formal_parameters" "array_pattern"))
   ("formal_parameters" ("function_declaration" "generator_function_declaration" "generator_function" "method_definition" "function" "arrow_function"))
   ("statement_identifier" ("continue_statement" "labeled_statement" "break_statement"))
   ("arguments" ("new_expression" "call_expression"))
   ("optional_chain" ("member_expression" "call_expression" "subscript_expression"))
   ("class_heritage" ("class" "class_declaration"))
   ("class_body" ("class" "class_declaration"))
   ("decorator" ("method_definition" "field_definition" "class_declaration" "class" "export_statement"))
   ("field_definition" ("class_body"))
   ("method_definition" ("object" "class_body"))
   ("class_static_block" ("class_body"))
   ("statement" ("switch_case" "for_statement" "for_in_statement" "switch_default" "with_statement" "else_clause" "program" "labeled_statement" "statement_block" "if_statement" "while_statement" "do_statement"))
   ("export_specifier" ("export_clause"))
   ("namespace_export" ("export_statement"))
   ("export_clause" ("export_statement"))
   ("sequence_expression" ("switch_case" "for_statement" "for_in_statement" "return_statement" "throw_statement" "jsx_expression" "expression_statement" "subscript_expression" "parenthesized_expression" "template_substitution" "sequence_expression"))
   ("property_identifier" ("member_expression" "method_definition" "field_definition" "jsx_attribute" "pair_pattern" "pair"))
   ("private_property_identifier" ("member_expression" "method_definition" "field_definition" "pair_pattern" "pair"))
   ("computed_property_name" ("field_definition" "method_definition" "pair_pattern" "pair"))
   ("glimmer_closing_tag" ("glimmer_template"))
   ("glimmer_opening_tag" ("glimmer_template"))
   ("else_clause" ("if_statement"))
   ("namespace_import" ("import_clause"))
   ("named_imports" ("import_clause"))
   ("import_clause" ("import_statement"))
   ("jsx_namespace_name" ("jsx_attribute" "jsx_closing_element" "jsx_opening_element" "jsx_self_closing_element"))
   ("jsx_expression" ("jsx_element" "jsx_self_closing_element" "jsx_attribute" "jsx_fragment" "jsx_opening_element"))
   ("nested_identifier" ("jsx_closing_element" "jsx_opening_element" "nested_identifier" "jsx_self_closing_element"))
   ("jsx_text" ("jsx_fragment" "jsx_element"))
   ("jsx_closing_element" ("jsx_element"))
   ("jsx_opening_element" ("jsx_element"))
   ("jsx_attribute" ("jsx_opening_element" "jsx_self_closing_element"))
   ("variable_declarator" ("variable_declaration" "lexical_declaration"))
   ("import_specifier" ("named_imports"))
   ("pair" ("object"))
   ("shorthand_property_identifier" ("object"))
   ("shorthand_property_identifier_pattern" ("object_pattern" "object_assignment_pattern"))
   ("pair_pattern" ("object_pattern"))
   ("object_assignment_pattern" ("object_pattern"))
   ("hash_bang_line" ("program"))
   ("regex_flags" ("regex"))
   ("regex_pattern" ("regex"))
   ("escape_sequence" ("template_string" "string"))
   ("string_fragment" ("string"))
   ("switch_case" ("switch_body"))
   ("switch_default" ("switch_body"))
   ("switch_body" ("switch_statement"))
   ("template_substitution" ("template_string"))
   ("finally_clause" ("try_statement"))
   ("catch_clause" ("try_statement"))
  ) 
)
;; END production rules for jsx





;; START Auto-generated production rules for `go'
(defconst combobulate-rules-go 
 '(("_expression" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("_simple_statement" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "short_var_declaration" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "inc_statement" "true" "iota" "send_statement" "rune_literal" "index_expression" "assignment_statement" "binary_expression" "call_expression" "dec_statement" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("_simple_type" (:*unnamed* ("type_identifier" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("_statement" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal"))) 
 ("_type" (:*unnamed* ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("argument_list" (:*unnamed* ("false" "type_assertion_expression" "pointer_type" "raw_string_literal" "parenthesized_expression" "map_type" "struct_type" "type_identifier" "iota" "function_type" "rune_literal" "index_expression" "qualified_type" "array_type" "call_expression" "variadic_argument" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "parenthesized_type" "float_literal" "composite_literal" "slice_expression" "selector_expression" "interpreted_string_literal" "negated_type" "identifier" "slice_type" "nil" "generic_type" "binary_expression" "union_type" "interface_type" "true" "int_literal" "channel_type"))) 
 ("array_type" (:element ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type") :length ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("assignment_statement" (:left ("expression_list") :operator nil :right ("expression_list"))) 
 ("binary_expression" (:left ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :operator nil :right ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("block" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal"))) 
 ("break_statement" (:*unnamed* ("label_name"))) 
 ("call_expression" (:arguments ("argument_list") :function ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :type_arguments ("type_arguments"))) 
 ("channel_type" (:value ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("communication_case" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal") :communication ("receive_statement" "send_statement"))) 
 ("composite_literal" (:body ("literal_value") :type ("type_identifier" "implicit_length_array_type" "qualified_type" "array_type" "slice_type" "map_type" "struct_type" "generic_type"))) 
 ("const_declaration" (:*unnamed* ("const_spec"))) 
 ("const_spec" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type") :value ("expression_list"))) 
 ("continue_statement" (:*unnamed* ("label_name"))) 
 ("dec_statement" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("default_case" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal"))) 
 ("defer_statement" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("expression_case" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal") :value ("expression_list"))) 
 ("expression_list" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("expression_switch_statement" (:*unnamed* ("expression_case" "default_case") :initializer ("float_literal" "composite_literal" "slice_expression" "selector_expression" "short_var_declaration" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "inc_statement" "true" "iota" "send_statement" "rune_literal" "index_expression" "assignment_statement" "binary_expression" "call_expression" "dec_statement" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :value ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("field_declaration" (:name ("field_identifier") :tag ("raw_string_literal" "interpreted_string_literal") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("field_declaration_list" (:*unnamed* ("field_declaration"))) 
 ("for_clause" (:condition ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :initializer ("float_literal" "composite_literal" "slice_expression" "selector_expression" "short_var_declaration" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "inc_statement" "true" "iota" "send_statement" "rune_literal" "index_expression" "assignment_statement" "binary_expression" "call_expression" "dec_statement" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :update ("float_literal" "composite_literal" "slice_expression" "selector_expression" "short_var_declaration" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "inc_statement" "true" "iota" "send_statement" "rune_literal" "index_expression" "assignment_statement" "binary_expression" "call_expression" "dec_statement" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("for_statement" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "for_clause" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "range_clause" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :body ("block"))) 
 ("func_literal" (:body ("block") :parameters ("parameter_list") :result ("type_identifier" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "parameter_list" "struct_type" "generic_type" "channel_type"))) 
 ("function_declaration" (:body ("block") :name ("identifier") :parameters ("parameter_list") :result ("type_identifier" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "parameter_list" "struct_type" "generic_type" "channel_type") :type_parameters ("type_parameter_list"))) 
 ("function_type" (:parameters ("parameter_list") :result ("type_identifier" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "parameter_list" "struct_type" "generic_type" "channel_type"))) 
 ("generic_type" (:type ("negated_type" "union_type" "type_identifier" "qualified_type") :type_arguments ("type_arguments"))) 
 ("go_statement" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("goto_statement" (:*unnamed* ("label_name"))) 
 ("if_statement" (:alternative ("block" "if_statement") :condition ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :consequence ("block") :initializer ("float_literal" "composite_literal" "slice_expression" "selector_expression" "short_var_declaration" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "inc_statement" "true" "iota" "send_statement" "rune_literal" "index_expression" "assignment_statement" "binary_expression" "call_expression" "dec_statement" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("implicit_length_array_type" (:element ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("import_declaration" (:*unnamed* ("import_spec" "import_spec_list"))) 
 ("import_spec" (:name ("blank_identifier" "package_identifier" "dot") :path ("raw_string_literal" "interpreted_string_literal"))) 
 ("import_spec_list" (:*unnamed* ("import_spec"))) 
 ("inc_statement" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("index_expression" (:index ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :operand ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("interface_type" (:*unnamed* ("method_spec" "constraint_elem" "struct_elem"))) 
 ("interpreted_string_literal" (:*unnamed* ("escape_sequence"))) 
 ("keyed_element" (:*unnamed* ("literal_element"))) 
 ("labeled_statement" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal") :label ("label_name"))) 
 ("literal_element" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "literal_value" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("literal_value" (:*unnamed* ("keyed_element" "literal_element"))) 
 ("map_type" (:key ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type") :value ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("method_declaration" (:body ("block") :name ("field_identifier") :parameters ("parameter_list") :receiver ("parameter_list") :result ("type_identifier" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "parameter_list" "struct_type" "generic_type" "channel_type"))) 
 ("method_spec" (:name ("field_identifier") :parameters ("parameter_list") :result ("type_identifier" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "parameter_list" "struct_type" "generic_type" "channel_type"))) 
 ("negated_type" (:*unnamed* ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("package_clause" (:*unnamed* ("package_identifier"))) 
 ("parameter_declaration" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("parameter_list" (:*unnamed* ("parameter_declaration" "variadic_parameter_declaration"))) 
 ("parenthesized_expression" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("parenthesized_type" (:*unnamed* ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("pointer_type" (:*unnamed* ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("qualified_type" (:name ("type_identifier") :package ("package_identifier"))) 
 ("range_clause" (:left ("expression_list") :right ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("receive_statement" (:left ("expression_list") :right ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("return_statement" (:*unnamed* ("expression_list"))) 
 ("select_statement" (:*unnamed* ("communication_case" "default_case"))) 
 ("selector_expression" (:field ("field_identifier") :operand ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("send_statement" (:channel ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :value ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("short_var_declaration" (:left ("expression_list") :right ("expression_list"))) 
 ("slice_expression" (:capacity ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :end ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :operand ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :start ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("slice_type" (:element ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("source_file" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "function_declaration" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "import_declaration" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "package_clause" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "method_declaration" "true" "send_statement" "int_literal"))) 
 ("struct_elem" (:*unnamed* ("struct_term"))) 
 ("struct_term" (:*unnamed* ("struct_type"))) 
 ("struct_type" (:*unnamed* ("field_declaration_list"))) 
 ("type_alias" (:name ("type_identifier") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("type_arguments" (:*unnamed* ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("type_assertion_expression" (:operand ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("type_case" (:*unnamed* ("type_assertion_expression" "false" "go_statement" "raw_string_literal" "parenthesized_expression" "if_statement" "type_declaration" "iota" "empty_statement" "rune_literal" "index_expression" "type_switch_statement" "continue_statement" "return_statement" "defer_statement" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "float_literal" "slice_expression" "composite_literal" "short_var_declaration" "for_statement" "selector_expression" "var_declaration" "interpreted_string_literal" "identifier" "nil" "inc_statement" "goto_statement" "fallthrough_statement" "break_statement" "const_declaration" "assignment_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "select_statement" "dec_statement" "true" "send_statement" "int_literal") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("type_conversion_expression" (:operand ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("type_declaration" (:*unnamed* ("type_spec" "type_alias"))) 
 ("type_parameter_list" (:*unnamed* ("parameter_declaration"))) 
 ("type_spec" (:name ("type_identifier") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type") :type_parameters ("type_parameter_list"))) 
 ("type_switch_statement" (:*unnamed* ("default_case" "type_case") :alias ("expression_list") :initializer ("float_literal" "composite_literal" "slice_expression" "selector_expression" "short_var_declaration" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "inc_statement" "true" "iota" "send_statement" "rune_literal" "index_expression" "assignment_statement" "binary_expression" "call_expression" "dec_statement" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :value ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("unary_expression" (:operand ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal") :operator nil)) 
 ("union_type" (:*unnamed* ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
 ("var_declaration" (:*unnamed* ("var_spec"))) 
 ("var_spec" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type") :value ("expression_list"))) 
 ("variadic_argument" (:*unnamed* ("float_literal" "composite_literal" "slice_expression" "selector_expression" "false" "type_assertion_expression" "interpreted_string_literal" "identifier" "raw_string_literal" "parenthesized_expression" "nil" "true" "iota" "rune_literal" "index_expression" "binary_expression" "call_expression" "type_conversion_expression" "unary_expression" "func_literal" "imaginary_literal" "int_literal"))) 
 ("variadic_parameter_declaration" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "function_type" "qualified_type" "array_type" "negated_type" "pointer_type" "slice_type" "union_type" "interface_type" "map_type" "struct_type" "generic_type" "channel_type"))) 
))

(defconst combobulate-rules-go-inverted 
 '(("float_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("composite_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("slice_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("selector_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("false" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("type_assertion_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("interpreted_string_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "import_spec" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement" "field_declaration"))
   ("identifier" ("argument_list" "for_clause" "type_assertion_expression" "variadic_parameter_declaration" "go_statement" "parenthesized_expression" "if_statement" "function_declaration" "const_spec" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "parameter_declaration" "var_spec" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("raw_string_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "import_spec" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement" "field_declaration"))
   ("parenthesized_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("nil" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("true" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("iota" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("rune_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("index_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("binary_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("call_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("type_conversion_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("unary_expression" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("func_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("imaginary_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("int_literal" ("argument_list" "for_clause" "type_assertion_expression" "go_statement" "parenthesized_expression" "if_statement" "expression_case" "type_switch_statement" "index_expression" "array_type" "defer_statement" "call_expression" "variadic_argument" "type_conversion_expression" "range_clause" "literal_element" "unary_expression" "_expression" "type_case" "for_statement" "default_case" "selector_expression" "slice_expression" "receive_statement" "communication_case" "_simple_statement" "expression_switch_statement" "block" "binary_expression" "labeled_statement" "source_file" "dec_statement" "_statement" "expression_list" "inc_statement" "send_statement"))
   ("short_var_declaration" ("communication_case" "_simple_statement" "default_case" "expression_case" "type_switch_statement" "expression_switch_statement" "for_clause" "block" "labeled_statement" "source_file" "_statement" "if_statement" "type_case"))
   ("inc_statement" ("communication_case" "_simple_statement" "default_case" "expression_case" "type_switch_statement" "expression_switch_statement" "for_clause" "block" "labeled_statement" "source_file" "_statement" "if_statement" "type_case"))
   ("send_statement" ("communication_case" "_simple_statement" "default_case" "expression_case" "type_switch_statement" "expression_switch_statement" "for_clause" "block" "labeled_statement" "source_file" "_statement" "if_statement" "type_case"))
   ("assignment_statement" ("communication_case" "_simple_statement" "default_case" "expression_case" "type_switch_statement" "expression_switch_statement" "for_clause" "block" "labeled_statement" "source_file" "_statement" "if_statement" "type_case"))
   ("dec_statement" ("communication_case" "_simple_statement" "default_case" "expression_case" "type_switch_statement" "expression_switch_statement" "for_clause" "block" "labeled_statement" "source_file" "_statement" "if_statement" "type_case"))
   ("type_identifier" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "qualified_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "generic_type" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("function_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("qualified_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "generic_type" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("array_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("negated_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "generic_type" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("pointer_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("slice_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("union_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "generic_type" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("interface_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("map_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("struct_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "struct_term" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("generic_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "composite_literal" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("channel_type" ("_type" "argument_list" "_simple_type" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "function_declaration" "const_spec" "method_spec" "function_type" "array_type" "type_conversion_expression" "func_literal" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "method_declaration" "type_spec" "field_declaration"))
   ("go_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("if_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "if_statement" "type_case"))
   ("type_declaration" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("empty_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("type_switch_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("continue_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("return_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("defer_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("for_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("var_declaration" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("goto_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("fallthrough_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("break_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("const_declaration" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("expression_switch_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("block" ("communication_case" "function_declaration" "expression_case" "default_case" "for_statement" "block" "labeled_statement" "source_file" "_statement" "method_declaration" "if_statement" "func_literal" "type_case"))
   ("labeled_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("select_statement" ("communication_case" "expression_case" "default_case" "block" "labeled_statement" "source_file" "_statement" "type_case"))
   ("parenthesized_type" ("_type" "argument_list" "type_assertion_expression" "pointer_type" "variadic_parameter_declaration" "channel_type" "map_type" "const_spec" "array_type" "type_conversion_expression" "type_arguments" "type_case" "parenthesized_type" "implicit_length_array_type" "negated_type" "parameter_declaration" "slice_type" "type_alias" "var_spec" "union_type" "type_spec" "field_declaration"))
   ("variadic_argument" ("argument_list"))
   ("expression_list" ("const_spec" "expression_case" "type_switch_statement" "short_var_declaration" "assignment_statement" "return_statement" "receive_statement" "range_clause" "var_spec"))
   ("label_name" ("continue_statement" "goto_statement" "labeled_statement" "break_statement"))
   ("argument_list" ("call_expression"))
   ("type_arguments" ("call_expression" "generic_type"))
   ("receive_statement" ("communication_case"))
   ("literal_value" ("literal_element" "composite_literal"))
   ("implicit_length_array_type" ("composite_literal"))
   ("const_spec" ("const_declaration"))
   ("expression_case" ("expression_switch_statement"))
   ("default_case" ("expression_switch_statement" "select_statement" "type_switch_statement"))
   ("field_identifier" ("method_spec" "method_declaration" "selector_expression" "field_declaration"))
   ("field_declaration" ("field_declaration_list"))
   ("for_clause" ("for_statement"))
   ("range_clause" ("for_statement"))
   ("parameter_list" ("function_declaration" "method_spec" "function_type" "method_declaration" "func_literal"))
   ("type_parameter_list" ("function_declaration" "type_spec"))
   ("import_spec" ("import_declaration" "import_spec_list"))
   ("import_spec_list" ("import_declaration"))
   ("blank_identifier" ("import_spec"))
   ("package_identifier" ("qualified_type" "import_spec" "package_clause"))
   ("dot" ("import_spec"))
   ("method_spec" ("interface_type"))
   ("constraint_elem" ("interface_type"))
   ("struct_elem" ("interface_type"))
   ("escape_sequence" ("interpreted_string_literal"))
   ("literal_element" ("keyed_element" "literal_value"))
   ("keyed_element" ("literal_value"))
   ("parameter_declaration" ("parameter_list" "type_parameter_list"))
   ("variadic_parameter_declaration" ("parameter_list"))
   ("communication_case" ("select_statement"))
   ("function_declaration" ("source_file"))
   ("import_declaration" ("source_file"))
   ("package_clause" ("source_file"))
   ("method_declaration" ("source_file"))
   ("struct_term" ("struct_elem"))
   ("field_declaration_list" ("struct_type"))
   ("type_spec" ("type_declaration"))
   ("type_alias" ("type_declaration"))
   ("type_case" ("type_switch_statement"))
   ("var_spec" ("var_declaration"))
  ) 
)
;; END production rules for go





;; START Auto-generated production rules for `python'
(defconst combobulate-rules-python 
 '(("_compound_statement" (:*unnamed* ("match_statement" "decorated_definition" "for_statement" "with_statement" "function_definition" "try_statement" "if_statement" "while_statement" "class_definition"))) 
 ("_simple_statement" (:*unnamed* ("future_import_statement" "delete_statement" "break_statement" "exec_statement" "continue_statement" "return_statement" "expression_statement" "global_statement" "nonlocal_statement" "print_statement" "raise_statement" "import_from_statement" "assert_statement" "pass_statement" "import_statement"))) 
 ("expression" (:*unnamed* ("as_pattern" "boolean_operator" "named_expression" "lambda" "not_operator" "conditional_expression" "primary_expression" "comparison_operator"))) 
 ("parameter" (:*unnamed* ("dictionary_splat_pattern" "positional_separator" "typed_parameter" "keyword_separator" "default_parameter" "identifier" "tuple_pattern" "typed_default_parameter" "list_splat_pattern"))) 
 ("pattern" (:*unnamed* ("list_splat_pattern" "identifier" "tuple_pattern" "subscript" "attribute" "list_pattern"))) 
 ("primary_expression" (:*unnamed* ("ellipsis" "list" "subscript" "generator_expression" "false" "identifier" "string" "parenthesized_expression" "dictionary" "set_comprehension" "float" "attribute" "true" "list_splat" "none" "call" "integer" "list_comprehension" "await" "dictionary_comprehension" "concatenated_string" "unary_operator" "binary_operator" "tuple" "set"))) 
 ("aliased_import" (:alias ("identifier") :name ("dotted_name"))) 
 ("argument_list" (:*unnamed* ("parenthesized_expression" "expression" "keyword_argument" "dictionary_splat" "list_splat"))) 
 ("as_pattern" (:*unnamed* ("expression") :alias ("as_pattern_target"))) 
 ("assert_statement" (:*unnamed* ("expression"))) 
 ("assignment" (:left ("pattern" "pattern_list") :right ("assignment" "pattern_list" "expression" "expression_list" "augmented_assignment" "yield") :type ("type"))) 
 ("attribute" (:attribute ("identifier") :object ("primary_expression"))) 
 ("augmented_assignment" (:left ("pattern" "pattern_list") :operator nil :right ("assignment" "pattern_list" "expression" "expression_list" "augmented_assignment" "yield"))) 
 ("await" (:*unnamed* ("expression"))) 
 ("binary_operator" (:left ("primary_expression") :operator nil :right ("primary_expression"))) 
 ("block" (:*unnamed* ("match_statement" "for_statement" "with_statement" "exec_statement" "global_statement" "print_statement" "if_statement" "while_statement" "import_from_statement" "assert_statement" "class_definition" "pass_statement" "import_statement" "future_import_statement" "decorated_definition" "delete_statement" "break_statement" "continue_statement" "return_statement" "function_definition" "try_statement" "expression_statement" "nonlocal_statement" "raise_statement"))) 
 ("boolean_operator" (:left ("expression") :operator nil :right ("expression"))) 
 ("call" (:arguments ("argument_list" "generator_expression") :function ("primary_expression"))) 
 ("case_clause" (:consequence ("block") :guard ("if_clause") :pattern ("case_pattern"))) 
 ("chevron" (:*unnamed* ("expression"))) 
 ("class_definition" (:body ("block") :name ("identifier") :superclasses ("argument_list"))) 
 ("comparison_operator" (:*unnamed* ("primary_expression") :operators nil)) 
 ("concatenated_string" (:*unnamed* ("string"))) 
 ("conditional_expression" (:*unnamed* ("expression"))) 
 ("decorated_definition" (:*unnamed* ("decorator") :definition ("class_definition" "function_definition"))) 
 ("decorator" (:*unnamed* ("expression"))) 
 ("default_parameter" (:name ("identifier" "tuple_pattern") :value ("expression"))) 
 ("delete_statement" (:*unnamed* ("expression_list" "expression"))) 
 ("dictionary" (:*unnamed* ("pair" "dictionary_splat"))) 
 ("dictionary_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("pair"))) 
 ("dictionary_splat" (:*unnamed* ("expression"))) 
 ("dictionary_splat_pattern" (:*unnamed* ("identifier" "attribute" "subscript"))) 
 ("dotted_name" (:*unnamed* ("identifier"))) 
 ("elif_clause" (:condition ("expression") :consequence ("block"))) 
 ("else_clause" (:body ("block"))) 
 ("except_clause" (:*unnamed* ("block" "expression"))) 
 ("except_group_clause" (:*unnamed* ("block" "expression"))) 
 ("exec_statement" (:*unnamed* ("expression") :code ("string" "identifier"))) 
 ("expression_list" (:*unnamed* ("expression"))) 
 ("expression_statement" (:*unnamed* ("augmented_assignment" "assignment" "yield" "expression"))) 
 ("finally_clause" (:*unnamed* ("block"))) 
 ("for_in_clause" (:left ("pattern" "pattern_list") :right ("expression"))) 
 ("for_statement" (:alternative ("else_clause") :body ("block") :left ("pattern" "pattern_list") :right ("expression_list" "expression"))) 
 ("format_expression" (:expression ("expression_list" "yield" "pattern_list" "expression") :format_specifier ("format_specifier") :type_conversion ("type_conversion"))) 
 ("format_specifier" (:*unnamed* ("format_expression"))) 
 ("function_definition" (:body ("block") :name ("identifier") :parameters ("parameters") :return_type ("type"))) 
 ("future_import_statement" (:name ("aliased_import" "dotted_name"))) 
 ("generator_expression" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression"))) 
 ("global_statement" (:*unnamed* ("identifier"))) 
 ("if_clause" (:*unnamed* ("expression"))) 
 ("if_statement" (:alternative ("elif_clause" "else_clause") :condition ("expression") :consequence ("block"))) 
 ("import_from_statement" (:*unnamed* ("wildcard_import") :module_name ("dotted_name" "relative_import") :name ("aliased_import" "dotted_name"))) 
 ("import_statement" (:name ("aliased_import" "dotted_name"))) 
 ("interpolation" (:expression ("expression_list" "yield" "pattern_list" "expression") :format_specifier ("format_specifier") :type_conversion ("type_conversion"))) 
 ("keyword_argument" (:name ("identifier") :value ("expression"))) 
 ("lambda" (:body ("expression") :parameters ("lambda_parameters"))) 
 ("lambda_parameters" (:*unnamed* ("parameter"))) 
 ("list" (:*unnamed* ("list_splat" "parenthesized_list_splat" "yield" "expression"))) 
 ("list_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression"))) 
 ("list_pattern" (:*unnamed* ("pattern"))) 
 ("list_splat" (:*unnamed* ("identifier" "subscript" "attribute" "expression"))) 
 ("list_splat_pattern" (:*unnamed* ("identifier" "attribute" "subscript"))) 
 ("match_statement" (:alternative ("case_clause") :subject ("expression"))) 
 ("module" (:*unnamed* ("match_statement" "for_statement" "with_statement" "exec_statement" "global_statement" "print_statement" "if_statement" "while_statement" "import_from_statement" "assert_statement" "class_definition" "pass_statement" "import_statement" "future_import_statement" "decorated_definition" "delete_statement" "break_statement" "continue_statement" "return_statement" "function_definition" "try_statement" "expression_statement" "nonlocal_statement" "raise_statement"))) 
 ("named_expression" (:name ("identifier") :value ("expression"))) 
 ("nonlocal_statement" (:*unnamed* ("identifier"))) 
 ("not_operator" (:argument ("expression"))) 
 ("pair" (:key ("expression") :value ("expression"))) 
 ("parameters" (:*unnamed* ("parameter"))) 
 ("parenthesized_expression" (:*unnamed* ("list_splat" "parenthesized_expression" "yield" "expression"))) 
 ("parenthesized_list_splat" (:*unnamed* ("parenthesized_expression" "list_splat"))) 
 ("pattern_list" (:*unnamed* ("pattern"))) 
 ("print_statement" (:*unnamed* ("chevron") :argument ("expression"))) 
 ("raise_statement" (:*unnamed* ("expression_list" "expression") :cause ("expression"))) 
 ("relative_import" (:*unnamed* ("import_prefix" "dotted_name"))) 
 ("return_statement" (:*unnamed* ("expression_list" "expression"))) 
 ("set" (:*unnamed* ("list_splat" "parenthesized_list_splat" "yield" "expression"))) 
 ("set_comprehension" (:*unnamed* ("if_clause" "for_in_clause") :body ("expression"))) 
 ("slice" (:*unnamed* ("expression"))) 
 ("string" (:*unnamed* ("string_start" "string_end" "interpolation" "string_content"))) 
 ("string_content" (:*unnamed* ("escape_sequence"))) 
 ("subscript" (:subscript ("slice" "expression") :value ("primary_expression"))) 
 ("try_statement" (:*unnamed* ("finally_clause" "else_clause" "except_clause" "except_group_clause") :body ("block"))) 
 ("tuple" (:*unnamed* ("list_splat" "parenthesized_list_splat" "yield" "expression"))) 
 ("tuple_pattern" (:*unnamed* ("pattern"))) 
 ("type" (:*unnamed* ("expression"))) 
 ("typed_default_parameter" (:name ("identifier") :type ("type") :value ("expression"))) 
 ("typed_parameter" (:*unnamed* ("identifier" "dictionary_splat_pattern" "list_splat_pattern") :type ("type"))) 
 ("unary_operator" (:argument ("primary_expression") :operator nil)) 
 ("while_statement" (:alternative ("else_clause") :body ("block") :condition ("expression"))) 
 ("with_clause" (:*unnamed* ("with_item"))) 
 ("with_item" (:value ("expression"))) 
 ("with_statement" (:*unnamed* ("with_clause") :body ("block"))) 
 ("yield" (:*unnamed* ("expression_list" "expression"))) 
))

(defconst combobulate-rules-python-inverted 
 '(("match_statement" ("block" "module" "_compound_statement"))
   ("decorated_definition" ("block" "module" "_compound_statement"))
   ("for_statement" ("block" "module" "_compound_statement"))
   ("with_statement" ("block" "module" "_compound_statement"))
   ("function_definition" ("block" "module" "decorated_definition" "_compound_statement"))
   ("try_statement" ("block" "module" "_compound_statement"))
   ("if_statement" ("block" "module" "_compound_statement"))
   ("while_statement" ("block" "module" "_compound_statement"))
   ("class_definition" ("block" "module" "decorated_definition" "_compound_statement"))
   ("future_import_statement" ("block" "module" "_simple_statement"))
   ("delete_statement" ("block" "module" "_simple_statement"))
   ("break_statement" ("block" "module" "_simple_statement"))
   ("exec_statement" ("block" "module" "_simple_statement"))
   ("continue_statement" ("block" "module" "_simple_statement"))
   ("return_statement" ("block" "module" "_simple_statement"))
   ("expression_statement" ("block" "module" "_simple_statement"))
   ("global_statement" ("block" "module" "_simple_statement"))
   ("nonlocal_statement" ("block" "module" "_simple_statement"))
   ("print_statement" ("block" "module" "_simple_statement"))
   ("raise_statement" ("block" "module" "_simple_statement"))
   ("import_from_statement" ("block" "module" "_simple_statement"))
   ("assert_statement" ("block" "module" "_simple_statement"))
   ("pass_statement" ("block" "module" "_simple_statement"))
   ("import_statement" ("block" "module" "_simple_statement"))
   ("as_pattern" ("expression"))
   ("boolean_operator" ("expression"))
   ("named_expression" ("expression"))
   ("lambda" ("expression"))
   ("not_operator" ("expression"))
   ("conditional_expression" ("expression"))
   ("primary_expression" ("call" "expression" "subscript" "unary_operator" "binary_operator" "comparison_operator" "attribute"))
   ("comparison_operator" ("expression"))
   ("dictionary_splat_pattern" ("typed_parameter" "parameter"))
   ("positional_separator" ("parameter"))
   ("typed_parameter" ("parameter"))
   ("keyword_separator" ("parameter"))
   ("default_parameter" ("parameter"))
   ("identifier" ("default_parameter" "global_statement" "typed_default_parameter" "primary_expression" "keyword_argument" "attribute" "nonlocal_statement" "exec_statement" "aliased_import" "class_definition" "list_splat_pattern" "list_splat" "dictionary_splat_pattern" "named_expression" "function_definition" "typed_parameter" "dotted_name" "pattern" "parameter"))
   ("tuple_pattern" ("pattern" "parameter" "default_parameter"))
   ("typed_default_parameter" ("parameter"))
   ("list_splat_pattern" ("pattern" "typed_parameter" "parameter"))
   ("subscript" ("dictionary_splat_pattern" "primary_expression" "pattern" "list_splat_pattern" "list_splat"))
   ("attribute" ("dictionary_splat_pattern" "primary_expression" "pattern" "list_splat_pattern" "list_splat"))
   ("list_pattern" ("pattern"))
   ("ellipsis" ("primary_expression"))
   ("list" ("primary_expression"))
   ("generator_expression" ("call" "primary_expression"))
   ("false" ("primary_expression"))
   ("string" ("exec_statement" "primary_expression" "concatenated_string"))
   ("parenthesized_expression" ("argument_list" "parenthesized_expression" "parenthesized_list_splat" "primary_expression"))
   ("dictionary" ("primary_expression"))
   ("set_comprehension" ("primary_expression"))
   ("float" ("primary_expression"))
   ("true" ("primary_expression"))
   ("list_splat" ("list" "parenthesized_list_splat" "argument_list" "parenthesized_expression" "tuple" "primary_expression" "set"))
   ("none" ("primary_expression"))
   ("call" ("primary_expression"))
   ("integer" ("primary_expression"))
   ("list_comprehension" ("primary_expression"))
   ("await" ("primary_expression"))
   ("dictionary_comprehension" ("primary_expression"))
   ("concatenated_string" ("primary_expression"))
   ("unary_operator" ("primary_expression"))
   ("binary_operator" ("primary_expression"))
   ("tuple" ("primary_expression"))
   ("set" ("primary_expression"))
   ("dotted_name" ("future_import_statement" "import_from_statement" "aliased_import" "import_statement" "relative_import"))
   ("expression" ("as_pattern" "match_statement" "format_expression" "list" "argument_list" "augmented_assignment" "except_clause" "not_operator" "dictionary_splat" "default_parameter" "print_statement" "parenthesized_expression" "typed_default_parameter" "if_statement" "type" "keyword_argument" "chevron" "if_clause" "yield" "elif_clause" "decorator" "delete_statement" "slice" "list_comprehension" "return_statement" "await" "raise_statement" "assignment" "tuple" "set" "boolean_operator" "for_statement" "exec_statement" "for_in_clause" "except_group_clause" "lambda" "subscript" "interpolation" "generator_expression" "with_item" "set_comprehension" "while_statement" "assert_statement" "pair" "list_splat" "named_expression" "conditional_expression" "expression_statement" "expression_list"))
   ("keyword_argument" ("argument_list"))
   ("dictionary_splat" ("argument_list" "dictionary"))
   ("as_pattern_target" ("as_pattern"))
   ("pattern" ("for_statement" "pattern_list" "for_in_clause" "augmented_assignment" "tuple_pattern" "assignment" "list_pattern"))
   ("pattern_list" ("format_expression" "for_statement" "for_in_clause" "augmented_assignment" "interpolation" "assignment"))
   ("assignment" ("augmented_assignment" "assignment" "expression_statement"))
   ("expression_list" ("format_expression" "delete_statement" "for_statement" "return_statement" "augmented_assignment" "interpolation" "raise_statement" "assignment" "yield"))
   ("augmented_assignment" ("augmented_assignment" "assignment" "expression_statement"))
   ("yield" ("format_expression" "list" "augmented_assignment" "interpolation" "expression_statement" "assignment" "parenthesized_expression" "tuple" "set"))
   ("type" ("typed_parameter" "assignment" "function_definition" "typed_default_parameter"))
   ("argument_list" ("call" "class_definition"))
   ("block" ("elif_clause" "case_clause" "for_statement" "with_statement" "except_group_clause" "else_clause" "except_clause" "function_definition" "try_statement" "if_statement" "while_statement" "finally_clause" "class_definition"))
   ("if_clause" ("case_clause" "list_comprehension" "generator_expression" "dictionary_comprehension" "set_comprehension"))
   ("case_pattern" ("case_clause"))
   ("decorator" ("decorated_definition"))
   ("pair" ("dictionary_comprehension" "dictionary"))
   ("for_in_clause" ("list_comprehension" "generator_expression" "dictionary_comprehension" "set_comprehension"))
   ("else_clause" ("while_statement" "try_statement" "for_statement" "if_statement"))
   ("format_specifier" ("format_expression" "interpolation"))
   ("type_conversion" ("format_expression" "interpolation"))
   ("format_expression" ("format_specifier"))
   ("parameters" ("function_definition"))
   ("aliased_import" ("future_import_statement" "import_from_statement" "import_statement"))
   ("elif_clause" ("if_statement"))
   ("wildcard_import" ("import_from_statement"))
   ("relative_import" ("import_from_statement"))
   ("lambda_parameters" ("lambda"))
   ("parameter" ("parameters" "lambda_parameters"))
   ("parenthesized_list_splat" ("set" "list" "tuple"))
   ("case_clause" ("match_statement"))
   ("chevron" ("print_statement"))
   ("import_prefix" ("relative_import"))
   ("string_start" ("string"))
   ("string_end" ("string"))
   ("interpolation" ("string"))
   ("string_content" ("string"))
   ("escape_sequence" ("string_content"))
   ("slice" ("subscript"))
   ("finally_clause" ("try_statement"))
   ("except_clause" ("try_statement"))
   ("except_group_clause" ("try_statement"))
   ("with_item" ("with_clause"))
   ("with_clause" ("with_statement"))
  ) 
)
;; END production rules for python





;; START Auto-generated production rules for `c'
(defconst combobulate-rules-c 
 '(("_abstract_declarator" (:*unnamed* ("abstract_function_declarator" "abstract_array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator"))) 
 ("_declarator" (:*unnamed* ("attributed_declarator" "identifier" "parenthesized_declarator" "array_declarator" "pointer_declarator" "function_declarator"))) 
 ("_expression" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("_field_declarator" (:*unnamed* ("attributed_declarator" "parenthesized_declarator" "array_declarator" "pointer_declarator" "field_identifier" "function_declarator"))) 
 ("_statement" (:*unnamed* ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement"))) 
 ("_type_declarator" (:*unnamed* ("attributed_declarator" "type_identifier" "parenthesized_declarator" "array_declarator" "pointer_declarator" "function_declarator"))) 
 ("_type_specifier" (:*unnamed* ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("abstract_array_declarator" (:*unnamed* ("type_qualifier") :declarator ("abstract_function_declarator" "abstract_array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator") :size ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("abstract_function_declarator" (:declarator ("abstract_function_declarator" "abstract_array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator") :parameters ("parameter_list"))) 
 ("abstract_parenthesized_declarator" (:*unnamed* ("abstract_function_declarator" "abstract_array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator"))) 
 ("abstract_pointer_declarator" (:*unnamed* ("type_qualifier") :declarator ("abstract_function_declarator" "abstract_array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator"))) 
 ("argument_list" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "preproc_defined" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("array_declarator" (:*unnamed* ("type_qualifier") :declarator ("attributed_declarator" "type_identifier" "parenthesized_declarator" "array_declarator" "identifier" "pointer_declarator" "field_identifier" "function_declarator") :size ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("assignment_expression" (:left ("field_expression" "identifier" "call_expression" "subscript_expression" "parenthesized_expression" "pointer_expression") :operator nil :right ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("attribute" (:*unnamed* ("argument_list") :name ("identifier") :prefix ("identifier"))) 
 ("attribute_declaration" (:*unnamed* ("attribute"))) 
 ("attribute_specifier" (:*unnamed* ("argument_list"))) 
 ("attributed_declarator" (:*unnamed* ("attributed_declarator" "type_identifier" "parenthesized_declarator" "attribute_declaration" "array_declarator" "identifier" "pointer_declarator" "field_identifier" "function_declarator"))) 
 ("attributed_statement" (:*unnamed* ("goto_statement" "attribute_declaration" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement"))) 
 ("binary_expression" (:left ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "preproc_defined" "number_literal" "unary_expression" "update_expression" "true") :operator nil :right ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "preproc_defined" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("bitfield_clause" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("call_expression" (:arguments ("argument_list") :function ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("case_statement" (:*unnamed* ("goto_statement" "compound_statement" "break_statement" "for_statement" "type_definition" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "if_statement" "while_statement" "do_statement" "declaration") :value ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("cast_expression" (:type ("type_descriptor") :value ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("char_literal" (:*unnamed* ("escape_sequence"))) 
 ("comma_expression" (:left ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :right ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("compound_literal_expression" (:type ("type_descriptor") :value ("initializer_list"))) 
 ("compound_statement" (:*unnamed* ("compound_statement" "for_statement" "preproc_if" "preproc_include" "attributed_statement" "union_specifier" "type_definition" "preproc_call" "case_statement" "preproc_def" "if_statement" "sized_type_specifier" "while_statement" "do_statement" "goto_statement" "type_identifier" "preproc_ifdef" "break_statement" "preproc_function_def" "continue_statement" "return_statement" "switch_statement" "primitive_type" "function_definition" "linkage_specification" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "macro_type_specifier" "declaration"))) 
 ("concatenated_string" (:*unnamed* ("string_literal"))) 
 ("conditional_expression" (:alternative ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :condition ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :consequence ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("declaration" (:*unnamed* ("attribute_declaration" "attribute_specifier" "storage_class_specifier" "type_qualifier" "ms_declspec_modifier") :declarator ("attributed_declarator" "identifier" "parenthesized_declarator" "array_declarator" "init_declarator" "pointer_declarator" "function_declarator") :type ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("declaration_list" (:*unnamed* ("compound_statement" "for_statement" "preproc_if" "preproc_include" "attributed_statement" "union_specifier" "type_definition" "preproc_call" "case_statement" "preproc_def" "if_statement" "sized_type_specifier" "while_statement" "do_statement" "goto_statement" "type_identifier" "preproc_ifdef" "break_statement" "preproc_function_def" "continue_statement" "return_statement" "switch_statement" "primitive_type" "function_definition" "linkage_specification" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "macro_type_specifier" "declaration"))) 
 ("do_statement" (:body ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement") :condition ("parenthesized_expression"))) 
 ("enum_specifier" (:body ("enumerator_list") :name ("type_identifier") :underlying_type ("primitive_type"))) 
 ("enumerator" (:name ("identifier") :value ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("enumerator_list" (:*unnamed* ("enumerator"))) 
 ("expression_statement" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("field_declaration" (:*unnamed* ("attribute_declaration" "attribute_specifier" "storage_class_specifier" "type_qualifier" "ms_declspec_modifier" "bitfield_clause") :declarator ("attributed_declarator" "parenthesized_declarator" "array_declarator" "pointer_declarator" "field_identifier" "function_declarator") :type ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("field_declaration_list" (:*unnamed* ("preproc_ifdef" "preproc_call" "preproc_def" "preproc_if" "preproc_function_def" "field_declaration"))) 
 ("field_designator" (:*unnamed* ("field_identifier"))) 
 ("field_expression" (:argument ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :field ("field_identifier") :operator nil)) 
 ("for_statement" (:body ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement") :condition ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :initializer ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true" "declaration") :update ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("function_declarator" (:*unnamed* ("attribute_specifier") :declarator ("attributed_declarator" "type_identifier" "parenthesized_declarator" "array_declarator" "identifier" "pointer_declarator" "field_identifier" "function_declarator") :parameters ("parameter_list"))) 
 ("function_definition" (:*unnamed* ("attribute_declaration" "attribute_specifier" "storage_class_specifier" "type_qualifier" "ms_call_modifier" "ms_declspec_modifier") :body ("compound_statement") :declarator ("attributed_declarator" "identifier" "parenthesized_declarator" "array_declarator" "pointer_declarator" "function_declarator") :type ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("generic_expression" (:*unnamed* ("field_expression" "type_descriptor" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("goto_statement" (:label ("statement_identifier"))) 
 ("if_statement" (:alternative ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement") :condition ("parenthesized_expression") :consequence ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement"))) 
 ("init_declarator" (:declarator ("attributed_declarator" "identifier" "parenthesized_declarator" "array_declarator" "pointer_declarator" "function_declarator") :value ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "initializer_list" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("initializer_list" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "initializer_list" "cast_expression" "initializer_pair" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("initializer_pair" (:designator ("field_designator" "subscript_designator") :value ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "initializer_list" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("labeled_statement" (:*unnamed* ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement") :label ("statement_identifier"))) 
 ("linkage_specification" (:body ("declaration_list" "declaration" "function_definition") :value ("string_literal"))) 
 ("macro_type_specifier" (:name ("identifier") :type ("type_descriptor"))) 
 ("ms_based_modifier" (:*unnamed* ("argument_list"))) 
 ("ms_declspec_modifier" (:*unnamed* ("identifier"))) 
 ("ms_pointer_modifier" (:*unnamed* ("ms_signed_ptr_modifier" "ms_unsigned_ptr_modifier" "ms_unaligned_ptr_modifier" "ms_restrict_modifier"))) 
 ("offsetof_expression" (:member ("field_identifier") :type ("type_descriptor"))) 
 ("parameter_declaration" (:*unnamed* ("attribute_declaration" "attribute_specifier" "storage_class_specifier" "type_qualifier" "ms_declspec_modifier") :declarator ("attributed_declarator" "parenthesized_declarator" "array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "identifier" "abstract_function_declarator" "abstract_array_declarator" "pointer_declarator" "function_declarator") :type ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("parameter_list" (:*unnamed* ("variadic_parameter" "parameter_declaration"))) 
 ("parenthesized_declarator" (:*unnamed* ("attributed_declarator" "type_identifier" "parenthesized_declarator" "array_declarator" "identifier" "pointer_declarator" "field_identifier" "function_declarator"))) 
 ("parenthesized_expression" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "preproc_defined" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("pointer_declarator" (:*unnamed* ("ms_pointer_modifier" "type_qualifier" "ms_based_modifier") :declarator ("attributed_declarator" "type_identifier" "parenthesized_declarator" "array_declarator" "identifier" "pointer_declarator" "field_identifier" "function_declarator"))) 
 ("pointer_expression" (:argument ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :operator nil)) 
 ("preproc_call" (:argument ("preproc_arg") :directive ("preproc_directive"))) 
 ("preproc_def" (:name ("identifier") :value ("preproc_arg"))) 
 ("preproc_defined" (:*unnamed* ("identifier"))) 
 ("preproc_elif" (:*unnamed* ("compound_statement" "preproc_if" "type_definition" "case_statement" "if_statement" "sized_type_specifier" "type_identifier" "continue_statement" "return_statement" "switch_statement" "primitive_type" "linkage_specification" "macro_type_specifier" "declaration" "for_statement" "preproc_include" "attributed_statement" "union_specifier" "preproc_call" "preproc_def" "while_statement" "do_statement" "goto_statement" "preproc_ifdef" "break_statement" "function_definition" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "preproc_function_def" "field_declaration") :alternative ("preproc_elif" "preproc_else") :condition ("binary_expression" "char_literal" "identifier" "call_expression" "preproc_defined" "parenthesized_expression" "number_literal" "unary_expression"))) 
 ("preproc_else" (:*unnamed* ("compound_statement" "preproc_if" "type_definition" "case_statement" "if_statement" "sized_type_specifier" "type_identifier" "continue_statement" "return_statement" "switch_statement" "primitive_type" "linkage_specification" "macro_type_specifier" "declaration" "for_statement" "preproc_include" "attributed_statement" "union_specifier" "preproc_call" "preproc_def" "while_statement" "do_statement" "goto_statement" "preproc_ifdef" "break_statement" "function_definition" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "preproc_function_def" "field_declaration"))) 
 ("preproc_function_def" (:name ("identifier") :parameters ("preproc_params") :value ("preproc_arg"))) 
 ("preproc_if" (:*unnamed* ("compound_statement" "preproc_if" "type_definition" "case_statement" "if_statement" "sized_type_specifier" "type_identifier" "continue_statement" "return_statement" "switch_statement" "primitive_type" "linkage_specification" "macro_type_specifier" "declaration" "for_statement" "preproc_include" "attributed_statement" "union_specifier" "preproc_call" "preproc_def" "while_statement" "do_statement" "goto_statement" "preproc_ifdef" "break_statement" "function_definition" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "preproc_function_def" "field_declaration") :alternative ("preproc_elif" "preproc_else") :condition ("binary_expression" "char_literal" "identifier" "call_expression" "preproc_defined" "parenthesized_expression" "number_literal" "unary_expression"))) 
 ("preproc_ifdef" (:*unnamed* ("compound_statement" "preproc_if" "type_definition" "case_statement" "if_statement" "sized_type_specifier" "type_identifier" "continue_statement" "return_statement" "switch_statement" "primitive_type" "linkage_specification" "macro_type_specifier" "declaration" "for_statement" "preproc_include" "attributed_statement" "union_specifier" "preproc_call" "preproc_def" "while_statement" "do_statement" "goto_statement" "preproc_ifdef" "break_statement" "function_definition" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "preproc_function_def" "field_declaration") :alternative ("preproc_elif" "preproc_else") :name ("identifier"))) 
 ("preproc_include" (:path ("string_literal" "identifier" "call_expression" "system_lib_string"))) 
 ("preproc_params" (:*unnamed* ("identifier"))) 
 ("return_statement" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "comma_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("sized_type_specifier" (:type ("type_identifier" "primitive_type"))) 
 ("sizeof_expression" (:type ("type_descriptor") :value ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("string_literal" (:*unnamed* ("escape_sequence"))) 
 ("struct_specifier" (:*unnamed* ("ms_declspec_modifier") :body ("field_declaration_list") :name ("type_identifier"))) 
 ("subscript_designator" (:*unnamed* ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("subscript_expression" (:argument ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :index ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true"))) 
 ("switch_statement" (:body ("compound_statement") :condition ("parenthesized_expression"))) 
 ("translation_unit" (:*unnamed* ("compound_statement" "for_statement" "preproc_if" "preproc_include" "attributed_statement" "union_specifier" "type_definition" "preproc_call" "case_statement" "preproc_def" "if_statement" "sized_type_specifier" "while_statement" "do_statement" "goto_statement" "type_identifier" "preproc_ifdef" "break_statement" "preproc_function_def" "continue_statement" "return_statement" "switch_statement" "primitive_type" "function_definition" "linkage_specification" "expression_statement" "labeled_statement" "enum_specifier" "struct_specifier" "macro_type_specifier" "declaration"))) 
 ("type_definition" (:*unnamed* ("type_qualifier") :declarator ("attributed_declarator" "type_identifier" "parenthesized_declarator" "array_declarator" "pointer_declarator" "function_declarator") :type ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("type_descriptor" (:*unnamed* ("type_qualifier") :declarator ("abstract_function_declarator" "abstract_array_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator") :type ("type_identifier" "enum_specifier" "sized_type_specifier" "union_specifier" "macro_type_specifier" "primitive_type" "struct_specifier"))) 
 ("unary_expression" (:argument ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "preproc_defined" "number_literal" "unary_expression" "update_expression" "true") :operator nil)) 
 ("union_specifier" (:*unnamed* ("ms_declspec_modifier") :body ("field_declaration_list") :name ("type_identifier"))) 
 ("update_expression" (:argument ("field_expression" "false" "null" "compound_literal_expression" "identifier" "subscript_expression" "parenthesized_expression" "string_literal" "sizeof_expression" "offsetof_expression" "cast_expression" "pointer_expression" "conditional_expression" "assignment_expression" "binary_expression" "generic_expression" "char_literal" "call_expression" "concatenated_string" "number_literal" "unary_expression" "update_expression" "true") :operator nil)) 
 ("while_statement" (:body ("goto_statement" "compound_statement" "break_statement" "for_statement" "attributed_statement" "continue_statement" "return_statement" "switch_statement" "expression_statement" "labeled_statement" "case_statement" "if_statement" "while_statement" "do_statement") :condition ("parenthesized_expression"))) 
))

(defconst combobulate-rules-c-inverted 
 '(("abstract_function_declarator" ("_abstract_declarator" "abstract_pointer_declarator" "type_descriptor" "abstract_parenthesized_declarator" "parameter_declaration" "abstract_function_declarator" "abstract_array_declarator"))
   ("abstract_array_declarator" ("_abstract_declarator" "abstract_pointer_declarator" "type_descriptor" "abstract_parenthesized_declarator" "parameter_declaration" "abstract_function_declarator" "abstract_array_declarator"))
   ("abstract_pointer_declarator" ("_abstract_declarator" "abstract_pointer_declarator" "type_descriptor" "abstract_parenthesized_declarator" "parameter_declaration" "abstract_function_declarator" "abstract_array_declarator"))
   ("abstract_parenthesized_declarator" ("_abstract_declarator" "abstract_pointer_declarator" "type_descriptor" "abstract_parenthesized_declarator" "parameter_declaration" "abstract_function_declarator" "abstract_array_declarator"))
   ("attributed_declarator" ("attributed_declarator" "_declarator" "parenthesized_declarator" "array_declarator" "type_definition" "init_declarator" "function_definition" "parameter_declaration" "_field_declarator" "field_declaration" "pointer_declarator" "declaration" "function_declarator" "_type_declarator"))
   ("identifier" ("field_expression" "parenthesized_declarator" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "pointer_declarator" "attribute" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "macro_type_specifier" "update_expression" "declaration" "preproc_elif" "_expression" "function_declarator" "for_statement" "preproc_include" "parameter_declaration" "preproc_def" "subscript_expression" "ms_declspec_modifier" "comma_expression" "attributed_declarator" "preproc_ifdef" "_declarator" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "function_definition" "binary_expression" "expression_statement" "preproc_defined" "preproc_params" "abstract_array_declarator" "preproc_function_def" "enumerator"))
   ("parenthesized_declarator" ("attributed_declarator" "_declarator" "parenthesized_declarator" "array_declarator" "type_definition" "init_declarator" "function_definition" "parameter_declaration" "_field_declarator" "field_declaration" "pointer_declarator" "declaration" "function_declarator" "_type_declarator"))
   ("array_declarator" ("attributed_declarator" "_declarator" "parenthesized_declarator" "array_declarator" "type_definition" "init_declarator" "function_definition" "parameter_declaration" "_field_declarator" "field_declaration" "pointer_declarator" "declaration" "function_declarator" "_type_declarator"))
   ("pointer_declarator" ("attributed_declarator" "_declarator" "parenthesized_declarator" "array_declarator" "type_definition" "init_declarator" "function_definition" "parameter_declaration" "_field_declarator" "field_declaration" "pointer_declarator" "declaration" "function_declarator" "_type_declarator"))
   ("function_declarator" ("attributed_declarator" "_declarator" "parenthesized_declarator" "array_declarator" "type_definition" "init_declarator" "function_definition" "parameter_declaration" "_field_declarator" "field_declaration" "pointer_declarator" "declaration" "function_declarator" "_type_declarator"))
   ("field_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("false" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("null" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("compound_literal_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("subscript_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("parenthesized_expression" ("field_expression" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "if_statement" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "switch_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "preproc_elif" "_expression" "for_statement" "subscript_expression" "while_statement" "do_statement" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("string_literal" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "linkage_specification" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "preproc_include" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "concatenated_string" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("sizeof_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("offsetof_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("cast_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("pointer_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("conditional_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("assignment_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("binary_expression" ("field_expression" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "preproc_elif" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("generic_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("char_literal" ("field_expression" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "preproc_elif" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("call_expression" ("field_expression" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "preproc_elif" "_expression" "for_statement" "preproc_include" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("concatenated_string" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("number_literal" ("field_expression" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "preproc_elif" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("unary_expression" ("field_expression" "preproc_if" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "preproc_elif" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("update_expression" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("true" ("field_expression" "init_declarator" "subscript_designator" "argument_list" "case_statement" "parenthesized_expression" "sizeof_expression" "initializer_list" "array_declarator" "return_statement" "pointer_expression" "generic_expression" "call_expression" "unary_expression" "update_expression" "_expression" "for_statement" "subscript_expression" "comma_expression" "cast_expression" "initializer_pair" "bitfield_clause" "conditional_expression" "assignment_expression" "binary_expression" "expression_statement" "abstract_array_declarator" "enumerator"))
   ("field_identifier" ("attributed_declarator" "field_expression" "parenthesized_declarator" "array_declarator" "field_designator" "_field_declarator" "pointer_declarator" "offsetof_expression" "function_declarator" "field_declaration"))
   ("goto_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("compound_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "function_definition" "switch_statement" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("break_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("for_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("attributed_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("continue_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("return_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("switch_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("expression_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("labeled_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("case_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("if_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("while_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("do_statement" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "attributed_statement" "declaration_list" "preproc_else" "labeled_statement" "case_statement" "_statement" "if_statement" "while_statement" "do_statement" "preproc_elif"))
   ("type_identifier" ("_type_specifier" "parenthesized_declarator" "compound_statement" "preproc_if" "type_definition" "preproc_else" "sized_type_specifier" "pointer_declarator" "_type_declarator" "array_declarator" "declaration_list" "declaration" "preproc_elif" "function_declarator" "translation_unit" "union_specifier" "type_descriptor" "parameter_declaration" "attributed_declarator" "preproc_ifdef" "function_definition" "struct_specifier" "enum_specifier" "field_declaration"))
   ("enum_specifier" ("preproc_ifdef" "translation_unit" "_type_specifier" "compound_statement" "preproc_if" "type_definition" "declaration_list" "function_definition" "type_descriptor" "preproc_else" "parameter_declaration" "declaration" "preproc_elif" "field_declaration"))
   ("sized_type_specifier" ("preproc_ifdef" "translation_unit" "_type_specifier" "compound_statement" "preproc_if" "type_definition" "declaration_list" "function_definition" "type_descriptor" "preproc_else" "parameter_declaration" "declaration" "preproc_elif" "field_declaration"))
   ("union_specifier" ("preproc_ifdef" "translation_unit" "_type_specifier" "compound_statement" "preproc_if" "type_definition" "declaration_list" "function_definition" "type_descriptor" "preproc_else" "parameter_declaration" "declaration" "preproc_elif" "field_declaration"))
   ("macro_type_specifier" ("preproc_ifdef" "translation_unit" "_type_specifier" "compound_statement" "preproc_if" "type_definition" "declaration_list" "function_definition" "type_descriptor" "preproc_else" "parameter_declaration" "declaration" "preproc_elif" "field_declaration"))
   ("primitive_type" ("preproc_ifdef" "translation_unit" "_type_specifier" "compound_statement" "preproc_if" "type_definition" "declaration_list" "function_definition" "type_descriptor" "preproc_else" "enum_specifier" "parameter_declaration" "sized_type_specifier" "declaration" "preproc_elif" "field_declaration"))
   ("struct_specifier" ("preproc_ifdef" "translation_unit" "_type_specifier" "compound_statement" "preproc_if" "type_definition" "declaration_list" "function_definition" "type_descriptor" "preproc_else" "parameter_declaration" "declaration" "preproc_elif" "field_declaration"))
   ("type_qualifier" ("array_declarator" "type_definition" "function_definition" "abstract_pointer_declarator" "type_descriptor" "parameter_declaration" "pointer_declarator" "abstract_array_declarator" "declaration" "field_declaration"))
   ("parameter_list" ("abstract_function_declarator" "function_declarator"))
   ("preproc_defined" ("preproc_if" "argument_list" "binary_expression" "parenthesized_expression" "unary_expression" "preproc_elif"))
   ("argument_list" ("call_expression" "attribute" "attribute_specifier" "ms_based_modifier"))
   ("attribute" ("attribute_declaration"))
   ("attribute_declaration" ("attributed_declarator" "attributed_statement" "function_definition" "parameter_declaration" "declaration" "field_declaration"))
   ("type_definition" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "case_statement" "preproc_elif"))
   ("declaration" ("preproc_ifdef" "translation_unit" "compound_statement" "for_statement" "preproc_if" "declaration_list" "linkage_specification" "preproc_else" "case_statement" "preproc_elif"))
   ("type_descriptor" ("cast_expression" "generic_expression" "compound_literal_expression" "sizeof_expression" "macro_type_specifier" "offsetof_expression"))
   ("escape_sequence" ("char_literal" "string_literal"))
   ("comma_expression" ("for_statement" "return_statement" "expression_statement" "parenthesized_expression" "comma_expression"))
   ("initializer_list" ("compound_literal_expression" "initializer_list" "init_declarator" "initializer_pair"))
   ("preproc_if" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "field_declaration_list" "preproc_elif"))
   ("preproc_include" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "preproc_elif"))
   ("preproc_call" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "field_declaration_list" "preproc_elif"))
   ("preproc_def" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "field_declaration_list" "preproc_elif"))
   ("preproc_ifdef" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "field_declaration_list" "preproc_elif"))
   ("preproc_function_def" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "field_declaration_list" "preproc_elif"))
   ("function_definition" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "linkage_specification" "preproc_else" "preproc_elif"))
   ("linkage_specification" ("preproc_ifdef" "translation_unit" "compound_statement" "preproc_if" "declaration_list" "preproc_else" "preproc_elif"))
   ("attribute_specifier" ("function_definition" "parameter_declaration" "declaration" "function_declarator" "field_declaration"))
   ("storage_class_specifier" ("parameter_declaration" "declaration" "function_definition" "field_declaration"))
   ("ms_declspec_modifier" ("union_specifier" "function_definition" "struct_specifier" "parameter_declaration" "declaration" "field_declaration"))
   ("init_declarator" ("declaration"))
   ("enumerator_list" ("enum_specifier"))
   ("enumerator" ("enumerator_list"))
   ("bitfield_clause" ("field_declaration"))
   ("field_declaration" ("preproc_ifdef" "preproc_if" "preproc_else" "field_declaration_list" "preproc_elif"))
   ("ms_call_modifier" ("function_definition"))
   ("statement_identifier" ("goto_statement" "labeled_statement"))
   ("initializer_pair" ("initializer_list"))
   ("field_designator" ("initializer_pair"))
   ("subscript_designator" ("initializer_pair"))
   ("declaration_list" ("linkage_specification"))
   ("ms_signed_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_unsigned_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_unaligned_ptr_modifier" ("ms_pointer_modifier"))
   ("ms_restrict_modifier" ("ms_pointer_modifier"))
   ("variadic_parameter" ("parameter_list"))
   ("parameter_declaration" ("parameter_list"))
   ("ms_pointer_modifier" ("pointer_declarator"))
   ("ms_based_modifier" ("pointer_declarator"))
   ("preproc_arg" ("preproc_call" "preproc_def" "preproc_function_def"))
   ("preproc_directive" ("preproc_call"))
   ("preproc_elif" ("preproc_ifdef" "preproc_if" "preproc_elif"))
   ("preproc_else" ("preproc_ifdef" "preproc_if" "preproc_elif"))
   ("preproc_params" ("preproc_function_def"))
   ("system_lib_string" ("preproc_include"))
   ("field_declaration_list" ("union_specifier" "struct_specifier"))
  ) 
)
;; END production rules for c





;; START Auto-generated production rules for `html'
(defconst combobulate-rules-html 
 '(("attribute" (:*unnamed* ("attribute_name" "quoted_attribute_value" "attribute_value"))) 
 ("element" (:*unnamed* ("entity" "start_tag" "self_closing_tag" "end_tag" "doctype" "element" "erroneous_end_tag" "script_element" "text" "style_element"))) 
 ("end_tag" (:*unnamed* ("tag_name"))) 
 ("erroneous_end_tag" (:*unnamed* ("erroneous_end_tag_name"))) 
 ("fragment" (:*unnamed* ("element" "erroneous_end_tag" "entity" "script_element" "text" "style_element" "doctype"))) 
 ("quoted_attribute_value" (:*unnamed* ("attribute_value"))) 
 ("script_element" (:*unnamed* ("raw_text" "start_tag" "end_tag"))) 
 ("self_closing_tag" (:*unnamed* ("attribute" "tag_name"))) 
 ("start_tag" (:*unnamed* ("attribute" "tag_name"))) 
 ("style_element" (:*unnamed* ("raw_text" "start_tag" "end_tag"))) 
))

(defconst combobulate-rules-html-inverted 
 '(("attribute_name" ("attribute"))
   ("quoted_attribute_value" ("attribute"))
   ("attribute_value" ("quoted_attribute_value" "attribute"))
   ("entity" ("element" "fragment"))
   ("start_tag" ("element" "style_element" "script_element"))
   ("self_closing_tag" ("element"))
   ("end_tag" ("element" "style_element" "script_element"))
   ("doctype" ("element" "fragment"))
   ("element" ("element" "fragment"))
   ("erroneous_end_tag" ("element" "fragment"))
   ("script_element" ("element" "fragment"))
   ("text" ("element" "fragment"))
   ("style_element" ("element" "fragment"))
   ("tag_name" ("start_tag" "self_closing_tag" "end_tag"))
   ("erroneous_end_tag_name" ("erroneous_end_tag"))
   ("raw_text" ("style_element" "script_element"))
   ("attribute" ("start_tag" "self_closing_tag"))
  ) 
)
;; END production rules for html





;; START Auto-generated production rules for `toml'
(defconst combobulate-rules-toml 
 '(("array" (:*unnamed* ("integer" "local_date" "string" "inline_table" "local_date_time" "float" "boolean" "array" "local_time" "offset_date_time"))) 
 ("document" (:*unnamed* ("table" "pair" "table_array_element"))) 
 ("dotted_key" (:*unnamed* ("bare_key" "quoted_key" "dotted_key"))) 
 ("inline_table" (:*unnamed* ("pair"))) 
 ("pair" (:*unnamed* ("dotted_key" "integer" "quoted_key" "local_date" "bare_key" "inline_table" "string" "local_date_time" "float" "boolean" "array" "local_time" "offset_date_time"))) 
 ("quoted_key" (:*unnamed* ("escape_sequence"))) 
 ("string" (:*unnamed* ("escape_sequence"))) 
 ("table" (:*unnamed* ("bare_key" "quoted_key" "pair" "dotted_key"))) 
 ("table_array_element" (:*unnamed* ("bare_key" "quoted_key" "pair" "dotted_key"))) 
))

(defconst combobulate-rules-toml-inverted 
 '(("integer" ("pair" "array"))
   ("local_date" ("pair" "array"))
   ("string" ("pair" "array"))
   ("inline_table" ("pair" "array"))
   ("local_date_time" ("pair" "array"))
   ("float" ("pair" "array"))
   ("boolean" ("pair" "array"))
   ("array" ("pair" "array"))
   ("local_time" ("pair" "array"))
   ("offset_date_time" ("pair" "array"))
   ("table" ("document"))
   ("pair" ("inline_table" "table" "document" "table_array_element"))
   ("table_array_element" ("document"))
   ("bare_key" ("dotted_key" "table" "pair" "table_array_element"))
   ("quoted_key" ("dotted_key" "table" "pair" "table_array_element"))
   ("dotted_key" ("dotted_key" "table" "pair" "table_array_element"))
   ("escape_sequence" ("string" "quoted_key"))
  ) 
)
;; END production rules for toml





;; START Auto-generated production rules for `json'
(defconst combobulate-rules-json 
 '(("_value" (:*unnamed* ("null" "string" "number" "object" "true" "array" "false"))) 
 ("array" (:*unnamed* ("null" "string" "number" "object" "true" "array" "false"))) 
 ("document" (:*unnamed* ("null" "string" "number" "object" "true" "array" "false"))) 
 ("object" (:*unnamed* ("pair"))) 
 ("pair" (:key ("string" "number") :value ("null" "string" "number" "object" "true" "array" "false"))) 
 ("string" (:*unnamed* ("string_content"))) 
 ("string_content" (:*unnamed* ("escape_sequence"))) 
))

(defconst combobulate-rules-json-inverted 
 '(("null" ("pair" "array" "_value" "document"))
   ("string" ("pair" "array" "_value" "document"))
   ("number" ("pair" "array" "_value" "document"))
   ("object" ("pair" "array" "_value" "document"))
   ("true" ("pair" "array" "_value" "document"))
   ("array" ("pair" "array" "_value" "document"))
   ("false" ("pair" "array" "_value" "document"))
   ("pair" ("object"))
   ("string_content" ("string"))
   ("escape_sequence" ("string_content"))
  ) 
)
;; END production rules for json





;; START Auto-generated production rules for `elixir'
(defconst combobulate-rules-elixir 
 '(("access_call" (:key ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call") :target ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("after_block" (:*unnamed* ("map" "quoted_atom" "stab_clause" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("anonymous_function" (:*unnamed* ("stab_clause"))) 
 ("arguments" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "keywords" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("binary_operator" (:left ("map" "quoted_atom" "list" "charlist" "char" "arguments" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call") :operator nil :right ("map" "quoted_atom" "list" "charlist" "char" "keywords" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("bitstring" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "keywords" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("block" (:*unnamed* ("map" "quoted_atom" "stab_clause" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("body" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("call" (:*unnamed* ("arguments" "do_block") :target ("identifier" "call" "dot"))) 
 ("catch_block" (:*unnamed* ("map" "quoted_atom" "stab_clause" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("charlist" (:*unnamed* ("escape_sequence" "interpolation" "quoted_content") :quoted_end nil :quoted_start nil)) 
 ("do_block" (:*unnamed* ("map" "quoted_atom" "stab_clause" "list" "else_block" "charlist" "char" "rescue_block" "catch_block" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "after_block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("dot" (:left ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call") :operator nil :right ("operator_identifier" "string" "identifier" "alias" "tuple" "charlist"))) 
 ("else_block" (:*unnamed* ("map" "quoted_atom" "stab_clause" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("interpolation" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("keywords" (:*unnamed* ("pair"))) 
 ("list" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "keywords" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("map" (:*unnamed* ("map_content" "struct"))) 
 ("map_content" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "keywords" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("pair" (:key ("keyword" "quoted_keyword") :value ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("quoted_atom" (:*unnamed* ("escape_sequence" "interpolation" "quoted_content") :quoted_end nil :quoted_start nil)) 
 ("quoted_keyword" (:*unnamed* ("escape_sequence" "interpolation" "quoted_content") :quoted_end nil :quoted_start nil)) 
 ("rescue_block" (:*unnamed* ("map" "quoted_atom" "stab_clause" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("sigil" (:*unnamed* ("sigil_name" "sigil_modifiers" "quoted_content" "escape_sequence" "interpolation") :quoted_end nil :quoted_start nil)) 
 ("source" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("stab_clause" (:left ("arguments" "binary_operator") :operator nil :right ("body"))) 
 ("string" (:*unnamed* ("escape_sequence" "interpolation" "quoted_content") :quoted_end nil :quoted_start nil)) 
 ("struct" (:*unnamed* ("identifier" "quoted_atom" "call" "alias" "atom" "dot" "unary_operator"))) 
 ("tuple" (:*unnamed* ("map" "quoted_atom" "list" "charlist" "char" "keywords" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call"))) 
 ("unary_operator" (:operand ("map" "quoted_atom" "list" "charlist" "char" "identifier" "string" "nil" "sigil" "anonymous_function" "float" "boolean" "operator_identifier" "call" "integer" "bitstring" "block" "dot" "unary_operator" "alias" "atom" "binary_operator" "tuple" "access_call") :operator nil)) 
))

(defconst combobulate-rules-elixir-inverted 
 '(("map" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("quoted_atom" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("list" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("charlist" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("char" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("identifier" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "call" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("string" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("nil" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("sigil" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("anonymous_function" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("float" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("boolean" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("operator_identifier" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("call" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "call" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("integer" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("bitstring" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("block" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("dot" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "call" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("unary_operator" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("alias" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("atom" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "struct" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("binary_operator" ("stab_clause" "list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("tuple" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("access_call" ("list" "body" "arguments" "rescue_block" "map_content" "source" "binary_operator" "tuple" "else_block" "catch_block" "interpolation" "pair" "do_block" "bitstring" "block" "after_block" "dot" "unary_operator" "access_call"))
   ("stab_clause" ("else_block" "do_block" "catch_block" "rescue_block" "block" "after_block" "anonymous_function"))
   ("keywords" ("list" "arguments" "bitstring" "map_content" "binary_operator" "tuple"))
   ("arguments" ("stab_clause" "call" "binary_operator"))
   ("do_block" ("call"))
   ("escape_sequence" ("quoted_atom" "charlist" "string" "quoted_keyword" "sigil"))
   ("interpolation" ("quoted_atom" "charlist" "string" "quoted_keyword" "sigil"))
   ("quoted_content" ("quoted_atom" "charlist" "string" "quoted_keyword" "sigil"))
   ("else_block" ("do_block"))
   ("rescue_block" ("do_block"))
   ("catch_block" ("do_block"))
   ("after_block" ("do_block"))
   ("pair" ("keywords"))
   ("map_content" ("map"))
   ("struct" ("map"))
   ("keyword" ("pair"))
   ("quoted_keyword" ("pair"))
   ("sigil_name" ("sigil"))
   ("sigil_modifiers" ("sigil"))
   ("body" ("stab_clause"))
  ) 
)
;; END production rules for elixir





(provide 'combobulate-rules)
